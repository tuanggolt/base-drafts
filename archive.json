{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2022-04-28T02:03:57.221164+00:00",
  "repo": "ietf-wg-privacypass/base-drafts",
  "labels": [
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "3a9daa"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "protocol",
      "description": "Issues related to the pp-protocol document",
      "color": "006b75"
    },
    {
      "name": "architecture",
      "description": "Issues related to the pp-architecture document",
      "color": "8ddd4f"
    },
    {
      "name": "http-api",
      "description": "Issues related to the pp-http-api document",
      "color": "e2a60d"
    },
    {
      "name": "charter",
      "description": "Issues related to the WG charter",
      "color": "ffc9e8"
    },
    {
      "name": "centralization",
      "description": "",
      "color": "1E0DFA"
    },
    {
      "name": "not-ready",
      "description": "",
      "color": "d93f0b"
    },
    {
      "name": "auth-scheme",
      "description": "",
      "color": "0e8a16"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWU1NzQ2OTIyODg=",
      "title": "Effective mechanism for identifying malicious servers",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/2",
      "state": "OPEN",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "help wanted",
        "architecture"
      ],
      "body": "Need to provide recommendations for section {{recs-srvr}} in the pp-architecture draft. It seems to me that it is easy for individual clients to identify and react to servers that seem to be acting maliciously. For example, the client can monitor and reject key material from servers where the configuration was last modified very recently and how often the rotations seem to be occurring. However, I'm not exactly sure what the reporting mechanism should be to alert other clients to this behavior.",
      "createdAt": "2020-03-03T14:06:06Z",
      "updatedAt": "2022-02-09T22:59:48Z",
      "closedAt": null,
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Mmm.. this is quite interesting. \r\n\r\nSomething that can be imposed to the server is to have a window of time in which rotations can't happen. I was thinking on something like this:\r\n\r\n* When a server updates their configuration (every 1 to 12 weeks as recommended), it does not immediately use this new configuration; but rather continues using the old one for shorter time frame (less than the 1 to 12 weeks, referred now as `t`), and makes clients aware of a new configuration that is coming. During `t`, the server cannot generate a new configuration. When `t` passes, the server starts using the new configuration (which clients can be sort of aware already). \r\n\r\nThis will make hard for a server to update in quick intervals, and that new configurations are not immediately used.\r\n\r\nI'm not sure about how much this will work, and I'll have to think more about it ;)\r\n\r\nSomething, that I don't know if is mentioned in the drafts is defining what happens is a server is rendered unavailable, in some sort of DoS. Maybe nothing can be done in that case...",
          "createdAt": "2020-03-23T08:03:39Z",
          "updatedAt": "2020-03-23T08:03:39Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "(Deleted spam comment)",
          "createdAt": "2022-02-09T22:59:47Z",
          "updatedAt": "2022-02-09T22:59:47Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWU1NzQ2OTM5MzM=",
      "title": "Should modified parameter hold times of ALL modifications?",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/3",
      "state": "CLOSED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "Currently, the `modified` parameter in each server key configuration only includes the latest modification. Perhaps this parameter should be an array that holds ALL of the times when modifications occurred? This would allow clients to check the frequency of key rotations for detecting malicious server behavior?",
      "createdAt": "2020-03-03T14:08:43Z",
      "updatedAt": "2020-03-06T14:59:38Z",
      "closedAt": "2020-03-06T14:59:38Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I've made a change that makes the value of `modified` in the config registry a vector, and all of the times when changes occur are appended to this vector.",
          "createdAt": "2020-03-06T14:59:38Z",
          "updatedAt": "2020-03-06T14:59:38Z"
        }
      ]
    },
    {
      "number": 5,
      "id": "MDU6SXNzdWU1Nzc2NDY0OTA=",
      "title": "Normalize setup",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/5",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "NONE",
      "assignees": [
        "alxdavids"
      ],
      "labels": [],
      "body": "You seem to be using [this setup](https://github.com/martinthomson/i-d-template).\r\n\r\nThe usual method for having multiple drafts in a repo is to just drop multiple files in the root directory.  The approach you have works until you try to do CI integration or access more advanced features, like the primitive support that exists for cross-document citations.\r\n\r\nSee [QUIC](https://github.com/quicwg/base-drafts) for a complete and operational setup.",
      "createdAt": "2020-03-09T04:10:54Z",
      "updatedAt": "2020-03-16T18:38:50Z",
      "closedAt": "2020-03-16T18:38:50Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWU1ODg3NDgzNTY=",
      "title": "incorrect link in readme on contributing",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/8",
      "state": "CLOSED",
      "author": "npdoty",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "\"guidelines for contributions\" links to some other WG (and its mailing list, etc.).",
      "createdAt": "2020-03-26T21:44:44Z",
      "updatedAt": "2020-06-25T14:22:28Z",
      "closedAt": "2020-06-25T14:22:28Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWU1OTk0ODIyMjc=",
      "title": "Add motivating use-cases section",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/9",
      "state": "CLOSED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "alxdavids"
      ],
      "labels": [
        "protocol"
      ],
      "body": "The Privacy Pass protocol was [originally designed](https://www.petsymposium.org/2018/files/papers/issue3/popets-2018-0026.pdf) as a response to providing an anonymous authorization users of anonymity-preserving services such as Tor. We should specify this motivating use-case (along with the applications that have arisen since) as a new section to the protocol document.\r\n\r\nThis will ensure that the standardisation of the protocol continues to be informed, and to be driven by, the key problems that we are trying to solve.\r\n\r\nFirst raised here: https://mailarchive.ietf.org/arch/msg/privacy-pass/7IXHIdXy7bEg3OMlScihmNKFRx4/",
      "createdAt": "2020-04-14T11:00:57Z",
      "updatedAt": "2020-07-09T10:26:00Z",
      "closedAt": "2020-07-09T10:26:00Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Added in #33 ",
          "createdAt": "2020-07-09T10:26:00Z",
          "updatedAt": "2020-07-09T10:26:00Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWU1OTk0ODYyNTc=",
      "title": "Establish assumed anonymity guarantees ",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/10",
      "state": "CLOSED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "alxdavids"
      ],
      "labels": [
        "architecture",
        "protocol"
      ],
      "body": "Throughout the drafts we currently use terms such as `privacy-preserving` & `anonymity` without establishing what properties we are assuming when using these terms. As mentioned on the mailing list, we should align around consistent terminology for the guarantees that we are offering (`anonymous authorization`) and then define exactly what this means in our context. \r\n\r\nIn particular, `anonymity`/`anonymous` refers to the fact that client redemption tokens cannot be linked to any other tokens issued by a given Issuer.\r\n\r\nFirst raised here: https://mailarchive.ietf.org/arch/msg/privacy-pass/7IXHIdXy7bEg3OMlScihmNKFRx4/",
      "createdAt": "2020-04-14T11:07:42Z",
      "updatedAt": "2020-07-09T10:25:41Z",
      "closedAt": "2020-07-09T10:25:41Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated anonymity guarantees as part of #33. The idea is that any instantiation of the protocol has to justify that it meets these guarantees to some appropriate extent. Either in the core pp-protocol doc, or in an extension.",
          "createdAt": "2020-07-09T10:25:40Z",
          "updatedAt": "2020-07-09T10:25:40Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWU1OTk0OTA0NTk=",
      "title": "Add discussion on supporting additional metadata in issued tokens",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/11",
      "state": "CLOSED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "architecture",
        "protocol"
      ],
      "body": "A number of applications expect the Servers to be able to add a small amount of metadata to the Privacy Pass protocol. We should add a discussion on how metadata should be added to tokens, and then describe the subsequent impact that this would have on the client's expected privacy budget. \r\n\r\nGenerally speaking, adding a bit of metadata to tokens is likely to have a very similar impact to introducing an extra Issuer, and so this is something that will have to be covered in the general parametrization guidelines in the architecture document. Specific mechanisms for adding metadata to tokens are yet to be proposed, but may appear as alternative instantiations in the protocol document, or be specified separately as individual extensions.",
      "createdAt": "2020-04-14T11:14:04Z",
      "updatedAt": "2020-07-07T17:29:58Z",
      "closedAt": "2020-07-07T17:29:58Z",
      "comments": []
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWU2MTI2ODg0NzY=",
      "title": "IssuanceMessage should identify the target ServerUpdate",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/13",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "... so that servers know clients are using the right key and haven't been downgraded, for whatever reason. In ECHO, we indicate this with a hash of the ECHOConfig structure, which would probably do the trick here, too. For example:\r\n\r\n~~~\r\nstruct {\r\n    uint8 update_digest[32];\r\n     ClientIssuanceElement issue_element<1..n>\r\n} IssuanceMessage;\r\n~~~\r\n\r\nwhere `update_digest = SHA256(server_update)`, or something.\r\n",
      "createdAt": "2020-05-05T15:23:16Z",
      "updatedAt": "2020-07-09T10:26:37Z",
      "closedAt": "2020-07-09T10:26:37Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "The protocol doc now assumes that the ciphersuite is known apriori when retrieving the Server public key data.",
          "createdAt": "2020-07-09T10:26:36Z",
          "updatedAt": "2020-07-09T10:26:36Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWU2MTI2ODg4MjI=",
      "title": "Rename IssuanceMessage to IssuanceRequest",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/14",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "This will match IssuanceResponse!",
      "createdAt": "2020-05-05T15:23:44Z",
      "updatedAt": "2020-10-16T14:25:27Z",
      "closedAt": "2020-10-16T14:25:22Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This was fixed.",
          "createdAt": "2020-10-16T14:25:22Z",
          "updatedAt": "2020-10-16T14:25:27Z"
        }
      ]
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWU2MTI2OTM5NDY=",
      "title": "Add \"configuration\" support",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/15",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "The main protocol document assumes that VOPRF is the main instantiation of PrivacyPass. It also has support for ciphersuites that augment this particular instantiation. It's not clear how we'd \"extend\" this protocol to support other features, such as public verifiability or the k-bits of metadata. These seem to be separate \"modes\" or \"configurations\" of PrivacyPass. (I don't think it makes sense to try and cast the metadata bit variant as a different ciphersuite for the main instantiation.) \r\n\r\nI propose we add some text describing different configurations. A configuration is an instantiation of the PrivacyPass API with certain properties. A configuration may (should?) also be extensible where applicable, e.g., in the ServerUpdate message or IssuanceRequest/Response messages. Interoperability across configurations would be unsupported, as they have would like have fundamentally different properties.\r\n\r\nSome initial configurations that come to mind are:\r\n- PrivacyPass with no metadata bits (VOPRF construction)\r\n- PrivacyPass with k metadata bits (Google's design)\r\n- PrivacyPass with public verifiability (blind signatures?)\r\n\r\ncc @alxdavids ",
      "createdAt": "2020-05-05T15:30:34Z",
      "updatedAt": "2020-07-09T10:27:54Z",
      "closedAt": "2020-07-09T10:27:53Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Added some more information about supporting additional metadata in #32. As discussed elsewhere, I think the way to go here is for extensions to just specify new ciphersuites with associated privacy/security guarantees. ",
          "createdAt": "2020-07-09T10:27:53Z",
          "updatedAt": "2020-07-09T10:27:53Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWU2MTI3MTQ2NjM=",
      "title": "Should ServerUpdate messages be versioned?",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/16",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "They don't currently have a version. That seems like something which would be good to add. Extension support seems useful, too, so we don't need to rev the version each time we need a small change.",
      "createdAt": "2020-05-05T16:00:44Z",
      "updatedAt": "2020-07-09T10:24:33Z",
      "closedAt": "2020-07-09T10:24:33Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "ServerUpdate does not exist anymore. New extensions should just add a new ciphersuite to the current enum. A server that uses an extension ciphersuite just specifies the ciphersuite with their public key data.",
          "createdAt": "2020-07-09T10:24:32Z",
          "updatedAt": "2020-07-09T10:24:32Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWU2MTI3OTk1NTA=",
      "title": "Rename SecretKey to PrivateKey?",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/17",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "SecretKey, to me, implies a symmetric key. Can we make this PrivateKey? That's the terminology used (mostly) in RFC7748, at least.",
      "createdAt": "2020-05-05T18:16:59Z",
      "updatedAt": "2020-07-09T10:23:40Z",
      "closedAt": "2020-07-09T10:23:40Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Done in #31 ",
          "createdAt": "2020-07-09T10:23:40Z",
          "updatedAt": "2020-07-09T10:23:40Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "MDU6SXNzdWU2MTI3OTk5NzU=",
      "title": "Simplify ServerSetup",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/18",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "This function outputs a `ServerConfig` and `ServerUpdate`. It might simplify things if this just output a config, from which the update could be created. ",
      "createdAt": "2020-05-05T18:17:44Z",
      "updatedAt": "2020-07-09T10:28:48Z",
      "closedAt": "2020-07-09T10:28:48Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Essentially this just corresponds to sampling a new keypair for a chosen ciphersuite now.",
          "createdAt": "2020-07-09T10:28:48Z",
          "updatedAt": "2020-07-09T10:28:48Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWU2MTQ4MTMxNTY=",
      "title": "Guidance on issuer selection",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/20",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "(This might be done already, but just in case...)\r\n\r\nWe should probably provide guidance on how clients should pick issuers. For example, if a client is presented with a choice of two issuers, what does it do? Pick the same one and use it \"all the time,\" pick one at random, or something else? ",
      "createdAt": "2020-05-08T15:27:06Z",
      "updatedAt": "2021-02-19T19:48:10Z",
      "closedAt": "2021-02-19T19:48:09Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I've added some advice on what Issuer features a Client should bear in mind when deciding which to choose. Do you think we still need advice on what to do if presented two at once? I imagine that the Client's should have hard-coded preferences.",
          "createdAt": "2020-07-09T10:21:03Z",
          "updatedAt": "2020-07-09T10:21:03Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Any opinions on best way forward here, happy to tackle this as it doesn't seem like a huge problem.",
          "createdAt": "2021-02-19T14:57:11Z",
          "updatedAt": "2021-02-19T14:57:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This might be something we punt on, as it's sort of akin to key discovery. I'll close this as such, given that you already have some text in the draft for it now.",
          "createdAt": "2021-02-19T19:48:09Z",
          "updatedAt": "2021-02-19T19:48:09Z"
        }
      ]
    },
    {
      "number": 21,
      "id": "MDU6SXNzdWU2MTQ4MTU0OTQ=",
      "title": "Define version/configuration registry",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/21",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture",
        "protocol"
      ],
      "body": "It might be easiest to fully specify a Privacy Pass configuration, e.g., \"Privacy Pass based on curve448_hkdf_sha512_ell2_ro,\" with a single identifier. That same identifier could go in the `ServerUpdate` structure as a way of fully defining the properties of the structure. ",
      "createdAt": "2020-05-08T15:31:01Z",
      "updatedAt": "2020-07-09T10:23:04Z",
      "closedAt": "2020-07-09T10:23:04Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Replaced Privacy Pass configuration with just a public key and associated ciphersuite. Changes to remove hard-coded key registry means that we don't have to be so prescriptive here anymore.",
          "createdAt": "2020-07-09T10:23:04Z",
          "updatedAt": "2020-07-09T10:23:04Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "MDU6SXNzdWU2MTQ4NDQ4Mjg=",
      "title": "Add milestones to Charter",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/22",
      "state": "CLOSED",
      "author": "jsalowey",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "charter"
      ],
      "body": "Something like:\r\n\r\n- Specification of protocol & surrounding architecture  - February 2021\r\n- Specification of application-layer requirements (including HTTP integration) - March 20201\r\n- Specification of HTTP browser API (in coordination with W3C) - April 20201",
      "createdAt": "2020-05-08T16:24:49Z",
      "updatedAt": "2020-05-14T16:51:44Z",
      "closedAt": "2020-05-14T16:51:44Z",
      "comments": []
    },
    {
      "number": 23,
      "id": "MDU6SXNzdWU2MTQ4NDY3MTY=",
      "title": "Add formal analysis to charter text",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/23",
      "state": "CLOSED",
      "author": "jsalowey",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "charter"
      ],
      "body": "Formal analysis is important for new security protocols.   The charter should include this, maybe add something like this at the end of paragraph 4:\r\n\r\n\"Formal analysis of the protocol will make sure the security and privacy properties of the protocol\r\nare well-understood and well-documented.\"",
      "createdAt": "2020-05-08T16:28:23Z",
      "updatedAt": "2020-05-15T15:38:31Z",
      "closedAt": "2020-05-15T15:38:31Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "This was done.",
          "createdAt": "2020-05-15T15:38:31Z",
          "updatedAt": "2020-05-15T15:38:31Z"
        }
      ]
    },
    {
      "number": 24,
      "id": "MDU6SXNzdWU2MTkwMDczMTM=",
      "title": "Rewrite privacy analysis based on properties of keys",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/24",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "The keys should not be rotated too frequently, for example. We can then refer to the existence of some mechanism that allows us to check this property, such as a log or registry. (We can then move the registry information out of the architecture document and into a separate one entirely.)",
      "createdAt": "2020-05-15T14:28:43Z",
      "updatedAt": "2020-07-09T10:21:30Z",
      "closedAt": "2020-07-09T10:21:29Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "This was done in #35 ",
          "createdAt": "2020-07-09T10:21:29Z",
          "updatedAt": "2020-07-09T10:21:29Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWU2NDU2MDYxNzI=",
      "title": "Update usage of VOPRF API",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/30",
      "state": "CLOSED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "API has been updated at https://github.com/cfrg/draft-irtf-cfrg-voprf/ quite substantially.",
      "createdAt": "2020-06-25T14:23:29Z",
      "updatedAt": "2020-07-07T17:28:04Z",
      "closedAt": "2020-07-07T17:28:04Z",
      "comments": []
    },
    {
      "number": 34,
      "id": "MDU6SXNzdWU2NDczODIzOTU=",
      "title": "Move some form of protocol interfaces to HTTP API doc",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/34",
      "state": "CLOSED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "architecture",
        "http-api"
      ],
      "body": "We currently have interfaces in the architecture document that lay out how messages should be sent and received. I think the architecture document should be solely focused on the building of the ecosystem in a way that maintains the utility of the privacy and security guarantees made by the protocol. The interfaces are mainly used by the HTTP API doc, and so I think this will be a better home for them.",
      "createdAt": "2020-06-29T13:35:25Z",
      "updatedAt": "2020-07-09T10:22:06Z",
      "closedAt": "2020-07-09T10:22:06Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I've removed the interfaces from the architecture doc (#35) and used the protocol API directly in the HTTP doc (#37)",
          "createdAt": "2020-07-09T10:22:06Z",
          "updatedAt": "2020-07-09T10:22:06Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWU2NTQ4MTI3NjQ=",
      "title": "Determine threshold for metadata bits (bytes?)",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/39",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "Different applications may want different numbers of metadata bits. This number should probably be bounded, otherwise Privacy Pass... is not so private. ",
      "createdAt": "2020-07-10T14:14:59Z",
      "updatedAt": "2021-02-18T17:51:04Z",
      "closedAt": "2021-02-18T17:51:04Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is done with the current parameterization text. So, closing.",
          "createdAt": "2021-02-18T17:51:03Z",
          "updatedAt": "2021-02-18T17:51:03Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWU2NTQ4MTQ1NTI=",
      "title": "Define extension for public verifiability",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/40",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "protocol",
        "not-ready"
      ],
      "body": "Per the charter.",
      "createdAt": "2020-07-10T14:17:42Z",
      "updatedAt": "2022-02-04T21:47:14Z",
      "closedAt": "2022-02-04T21:47:14Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Potential instantiation highlighted by @wbl on the mailing list: https://mailarchive.ietf.org/arch/msg/privacy-pass/BDOOhSLwB3uUJcfBiss6nUF5sUA/. Do we want to consider any other schemes?",
          "createdAt": "2020-08-11T11:37:21Z",
          "updatedAt": "2020-08-11T11:37:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Resolved in #87.",
          "createdAt": "2022-02-04T21:47:14Z",
          "updatedAt": "2022-02-04T21:47:14Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWU2NTQ5NjgyOTY=",
      "title": "Define extension for private metadata bit variant",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/42",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "protocol",
        "not-ready"
      ],
      "body": "We say it's possible, but let's be a bit more concrete.",
      "createdAt": "2020-07-10T18:41:47Z",
      "updatedAt": "2021-09-14T01:18:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this will depend on having a draft specification of the underlying cryptographic functionality.",
          "createdAt": "2020-08-11T09:49:36Z",
          "updatedAt": "2020-08-11T09:49:36Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Just so this is on the record somewhere: https://eprint.iacr.org/2020/072  (which is one possible version of the crypto for this).",
          "createdAt": "2021-09-14T01:18:41Z",
          "updatedAt": "2021-09-14T01:18:41Z"
        }
      ]
    },
    {
      "number": 44,
      "id": "MDU6SXNzdWU2OTY2Njk5NDM=",
      "title": "Specify redemption mode in public config",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/44",
      "state": "CLOSED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "architecture",
        "http-api",
        "not-ready"
      ],
      "body": "Servers should specify accepted redemption modes that they allow as a list associated with their public configuration. This would be a subset of the list `[\"single\", \"proxy\", \"async\", \"public\"]` corresponding to the redemptions modes in https://tools.ietf.org/html/draft-davidson-pp-architecture-01#section-5.\r\n\r\nIn all modes except \"single\" we should also allow optional specification of _allowed_ verifiers that can ask for tokens on the server's behalf. If one of these verifiers asks for a client token associated with the server, then the client will first check this list to ensure that the verifier exists before sending the token. This ensures that clients don't reveal which tokens they hold to untrusted verifiers.\r\n\r\ncc @chris-wood @dvorak42 ",
      "createdAt": "2020-09-09T09:54:40Z",
      "updatedAt": "2022-01-31T20:25:10Z",
      "closedAt": "2022-01-31T20:25:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Interesting. To what extent are these modes determined by the underlying cryptographic protocol? (The public redemption mode, for example, is certainly dependent on the underlying protocol.) ",
          "createdAt": "2021-02-18T18:49:58Z",
          "updatedAt": "2021-02-18T18:49:58Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "So the first 3 modes are essentially all symmetric running modes, but they should be agnostic to the specific choice of protocol. In deed `public` requires public-key analogues of Privacy Pass, but it shouldn't depend on the actual instantiation (in terms of cryptographic ciphersuite). Does this answer your question?",
          "createdAt": "2021-02-19T14:50:26Z",
          "updatedAt": "2021-02-19T14:50:26Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Requires moe discussion around what information is allowed in the config. This change would imply allowing identifiers for verifiers in the config, which could be URLs etc, but this may narrow use-cases. We should think about this more.",
          "createdAt": "2021-02-19T16:32:08Z",
          "updatedAt": "2021-02-19T16:32:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "It *seems* like a configuration should contain the minimal cryptographic information necessary to run the protocol securely. But this is indeed quite interesting because *who* clients run the protocol with may impact security. We could maybe allow for (sequences of) opaque identifiers to be provided in the config? Not sure. ",
          "createdAt": "2021-02-19T16:54:24Z",
          "updatedAt": "2021-02-19T16:54:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events. Closing.",
          "createdAt": "2022-01-31T20:25:09Z",
          "updatedAt": "2022-01-31T20:25:09Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWU2OTY2NzI0MjA=",
      "title": "Improve documentation on centralization",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/45",
      "state": "OPEN",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "centralization"
      ],
      "body": "There should be documentation that addresses the risks of the centralization in the current Privacy Pass architecture with potential solutions. This was raised in the previous WG meeting: https://codimd.ietf.org/notes-ietf-108-privacypass.\r\n\r\nThis documentation should either be incorporated into the architecture document as a section when discussing the shape of the ecosystem, and/or security considerations. There is also the option of declaring a separate document for addressing this.",
      "createdAt": "2020-09-09T09:58:04Z",
      "updatedAt": "2021-02-19T14:55:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "A draft has been put forward for this by Mark McFadden: https://tools.ietf.org/html/draft-mcfadden-pp-centralization-problem-00, and will be discussed at IETF 110. Will leave this open for now, until this draft (or some form of it) is accepted.",
          "createdAt": "2021-02-19T14:54:30Z",
          "updatedAt": "2021-02-19T14:54:30Z"
        }
      ]
    },
    {
      "number": 46,
      "id": "MDU6SXNzdWU2OTY2OTkzNTc=",
      "title": "Remove exposure of token in proxied-verifier",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/46",
      "state": "CLOSED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "protocol",
        "architecture",
        "not-ready"
      ],
      "body": "Currently, in the proxied-verifier server running mode, the entire redemption token is sent to the server. However, we may be able to avoid this by only sending the initial `data` inside the RedemptionRequest, and keeping the `tag` and `info` at the proxy. This is because `data` is operated on under the server key, while the rest of the information is just added to a hash function evaluation. This means that the token issuer only sees the token (and can then implement double-spending protection based on this), but nothing else about the request to the verifier.\r\n\r\nThe change will probably drop the requirement for the `VerifyFinalize` API in the VOPRF doc, which is also advantageous. Originally discussed with @chris-wood, @siyengar, and Zutian Luo.",
      "createdAt": "2020-09-09T10:36:58Z",
      "updatedAt": "2022-01-31T20:24:56Z",
      "closedAt": "2022-01-31T20:24:55Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood, I will take a look at this today. It would be nice to have this in ahead of the PrivateStats ciphersuites.. ",
          "createdAt": "2021-02-19T14:52:16Z",
          "updatedAt": "2021-02-19T14:52:16Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think that we're quite ready to move forward with this, but we can consider it for a future draft release.",
          "createdAt": "2021-02-21T09:12:34Z",
          "updatedAt": "2021-02-21T09:12:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Overcome by events. Closing.",
          "createdAt": "2022-01-31T20:24:55Z",
          "updatedAt": "2022-01-31T20:24:55Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWU3MjMyNzQyODk=",
      "title": "Describe negative consequences of centralization",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/47",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "We don't have a good way to address this (now), so we should minimally acknowledge the risks and consequences.",
      "createdAt": "2020-10-16T14:26:54Z",
      "updatedAt": "2021-02-18T18:48:09Z",
      "closedAt": "2021-02-18T18:48:09Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Dupe of #45. Closing.",
          "createdAt": "2021-02-18T18:48:09Z",
          "updatedAt": "2021-02-18T18:48:09Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWU3MjMyNzY5MTg=",
      "title": "Describe privacy implications of underlying transport protocol(s)",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/48",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "Token issuance and redemption flows from the same IP address, for example, would be linkable, but this isn't a break in the privacy pass protocol. We should discuss these orthogonal privacy considerations.",
      "createdAt": "2020-10-16T14:30:16Z",
      "updatedAt": "2021-02-19T14:51:14Z",
      "closedAt": "2021-02-19T14:51:14Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this is already addressed [in the draft](https://github.com/ietf-wg-privacypass/base-drafts/blob/master/draft-ietf-privacypass-architecture.md#client-identifying-information-client-ip). @alxdavids, if you agree, can you please close this?",
          "createdAt": "2021-02-18T18:47:24Z",
          "updatedAt": "2021-02-18T18:47:32Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, good point, closing.",
          "createdAt": "2021-02-19T14:51:14Z",
          "updatedAt": "2021-02-19T14:51:14Z"
        }
      ]
    },
    {
      "number": 49,
      "id": "MDU6SXNzdWU3NTA5MTI0NzU=",
      "title": "Token expiration",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/49",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "There's currently no text around token expiration. Minimally, we could say that tokens expire when issuer (and verifier) keys rotate. Do we also want to bake in mechanisms for expiration to be cryptographically bound to issued tokens? For example, one might imagine using PMB-like constructions to encode an expiration \"epoch\" into the metadata bits. The single metadata bit variant would allow two epochs that way. \r\n\r\n@dvorak42, @alxdavids: what do you think?",
      "createdAt": "2020-11-25T15:26:43Z",
      "updatedAt": "2021-02-19T14:47:18Z",
      "closedAt": "2021-02-19T14:47:18Z",
      "comments": [
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure what baking the expiry into the tokens gives that can't be managed by rotating the issuer/verifier keys (or using public metadata (which is effectively the key used to sign))? That way issuers that care about more fine grained token expiration use the key rotation for that and issuers that only care about coarse token expiration use it for other metadata, allowing the protocol to treat both in the same way?",
          "createdAt": "2020-11-30T16:30:53Z",
          "updatedAt": "2020-11-30T16:30:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, I think the only two options are (a) rotate keys or (b) include the expiry information as public metadata (and need not be tied to the key used to sign). I'm not advocating for one or the other. \r\n\r\n> That way issuers that care about more fine grained token expiration use the key rotation for that and issuers that only care about coarse token expiration use it for other metadata, allowing the protocol to treat both in the same way?\r\n\r\nSure, that's reasonable. We should probably have text on this point. (That's partly why I filed this issue.)",
          "createdAt": "2020-11-30T16:34:34Z",
          "updatedAt": "2020-11-30T16:34:34Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We should also make sure to note that the validity window does narrow the anonymity set.",
          "createdAt": "2020-12-11T22:50:12Z",
          "updatedAt": "2020-12-11T22:50:12Z"
        }
      ]
    },
    {
      "number": 50,
      "id": "MDU6SXNzdWU3NTQ5MjYwODU=",
      "title": "Accommodating two round protocols",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/50",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [
        "alxdavids"
      ],
      "labels": [
        "architecture",
        "protocol"
      ],
      "body": "Some protocols, like [blind Schnorr signature schemes](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.3.6950&rep=rep1&type=pdf), require more than 1 round trip to complete. Currently, the protocol assumes a protocol that runs in one round trip, with some offline public key distribution step. In particular, issuance request messages are mapped almost directly to the underlying OPRF blind/request message. \r\n\r\nWe should consider what needs to change, if anything, to accommodate these differently shaped protocols. I suggest we loosen the 1-1 restriction (?) from the Privacy Pass API to the underlying cryptographic protocol APIs. It just so happens that Privacy Pass maps nicely to the OPRF construction, but that need not be the case. For example, and hand waving over details, in the blind Schnorr case, an implementation of the issuance request flow could involve first fetching the nonce commitment from the server, and then sending a blinded value for evaluation. \r\n\r\n@dvorak42, what do you think?",
      "createdAt": "2020-12-02T04:21:45Z",
      "updatedAt": "2021-03-05T13:16:11Z",
      "closedAt": "2021-03-05T13:16:11Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@alxdavids what do you want to do here? Should we refactor the protocol to run in two rounds? Perhaps something like the following:\r\n\r\n- CommitRequest\r\n- CommitResponse\r\n- IssueRequest\r\n- IssueResponse\r\n\r\nDuring the commitment flow (first round trip), the server can provide any sort of nonce or whatever is needed for the underlying protocol. ",
          "createdAt": "2021-02-18T18:54:27Z",
          "updatedAt": "2021-02-18T18:54:27Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that sounds fine. Presumably in this architecture, the CommitRequest from the Client will mostly be an empty message (at least for 3-round protocols)?",
          "createdAt": "2021-02-19T14:45:56Z",
          "updatedAt": "2021-02-19T14:45:56Z"
        },
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "For 1 round protocols, would the key commitment/configuration could be used to provide a 'default' result to the CommitResponse, either hardcoded as part of the version (or some parameter in the configuration)?",
          "createdAt": "2021-02-19T15:01:00Z",
          "updatedAt": "2021-02-19T15:01:00Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For 1 round protocols, would the key commitment/configuration could be used to provide a 'default' result to the CommitResponse, either hardcoded as part of the version (or some parameter in the configuration)?\r\n\r\nNot sure! We'd have to play with it and see what works.",
          "createdAt": "2021-02-19T16:02:42Z",
          "updatedAt": "2021-02-19T16:02:42Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@alxdavids will draft a PR based on the commit request/response flow, where the response includes some implementation-specific handle to state needed for the subsequent issuance flow. For one round protocols, the handle will be a fixed (empty?) string passed to the issuance flow.",
          "createdAt": "2021-02-19T16:18:44Z",
          "updatedAt": "2021-02-19T16:18:44Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this has been fixed by #62, @chris-wood to confirm? ",
          "createdAt": "2021-03-05T09:34:28Z",
          "updatedAt": "2021-03-05T09:34:28Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "MDU6SXNzdWU3NjMwMTI2NjU=",
      "title": "Expand metadata discussion",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/51",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture",
        "protocol"
      ],
      "body": "There are several dimensions to metadata, including:\r\n\r\n- public vs private\r\n- verifiable vs non-verifiable\r\n- bounded or arbitrary-length\r\n\r\nIt's worth expanding on these dimensions. For example, the underlying cryptographic primitive may influence or limit one or more of these dimensions in a variety of ways. Also, whether metadata is public or private, or verifiable or not, is important for privacy reasons. (If metadata can't be verified, is it a tracking vector? Can private metadata track clients?)\r\n\r\nIn general, expounding upon these issues would likely be quite valuable for the draft.",
      "createdAt": "2020-12-11T22:49:16Z",
      "updatedAt": "2021-02-18T17:56:04Z",
      "closedAt": "2021-02-18T17:56:04Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWU3NzU2ODg2NzE=",
      "title": "Safari Extension",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/52",
      "state": "CLOSED",
      "author": "balupton",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-12-29T04:17:39Z",
      "updatedAt": "2021-01-04T12:34:42Z",
      "closedAt": "2021-01-04T12:34:42Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think there is any work associated with specific browsers that is going to be considered in this working group, so I'm going to close this.",
          "createdAt": "2021-01-04T12:34:42Z",
          "updatedAt": "2021-01-04T12:34:42Z"
        }
      ]
    },
    {
      "number": 53,
      "id": "MDU6SXNzdWU3NzY2OTMyNjE=",
      "title": "A related work: privacy-preserving asynchronous Single Sign-On (EL PASSO)",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/53",
      "state": "CLOSED",
      "author": "Zhiyi-Zhang",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi there,\r\n\r\nWe have been working on privacy-preserving Single Sign-On and we found our work, called EL PASSO, is very closely related to Privacy Pass.\r\nEL PASSO implements anonymous credentials, enables selective attribute disclosure, and allows users to prove properties about their identity without revealing it in the clear.\r\nWe also have accountability designed in: when a user misbehaves on a relying party, the relying party can report the user to authorities to reveal the identity of that user.\r\nThere are other interesting features in EL PASSO like inter-RP unlinkability and intro-RP linkability that can provide desired security properties.\r\n\r\nA preprint version can be found on arXiv: https://arxiv.org/abs/2002.10289 and a final version will appear in PETS 2021.\r\nWe hope this work can provide some useful input to Privacy Pass and we are also looking forward to future collaborations with Privacy Pass.",
      "createdAt": "2020-12-31T00:38:25Z",
      "updatedAt": "2021-01-05T16:50:08Z",
      "closedAt": "2021-01-05T16:50:08Z",
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@Zhiyi-Zhang Thanks for reaching out to Privacy Pass! Could you please [join the mailing list](https://www.ietf.org/mailman/listinfo/privacy-pass) and send this message there?  We use Github primarily for editing the text of draft documents, not for general discussions of new material.",
          "createdAt": "2021-01-05T16:50:08Z",
          "updatedAt": "2021-01-05T16:50:08Z"
        }
      ]
    },
    {
      "number": 63,
      "id": "MDU6SXNzdWU4MTI4NzUyNjk=",
      "title": "Accommodate client and server metadata ",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/63",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "The APIs currently do not allow clients or servers to supply metadata into the issuance flow. Absent a slot for metadata, how would one implement the PMB or the PrivateStats variants? One way would be to add client public metadata to the Generate API, and server public and private metadata to the Issue API, and communicate these in the requests and responses as needed. The instantiations/ciphersuites could then impose limits on these inputs as needed. For example, the PMB variant might limit the server private metadata to a single byte of value 0x00 or 0x01, and the public metadata would be empty. \r\n\r\n@dvorak42, would that be workable?\r\n",
      "createdAt": "2021-02-21T15:04:15Z",
      "updatedAt": "2022-02-09T22:59:17Z",
      "closedAt": "2022-02-09T22:59:16Z",
      "comments": [
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd guess it would be cleanest in the Issue API, especially for the private metadata variant, but seems like a reasonable way. The PrivateStats variant may need a bit more to support larger amounts of public metadata.",
          "createdAt": "2021-03-09T15:58:09Z",
          "updatedAt": "2021-03-09T15:58:09Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool. I'll prep a PR!",
          "createdAt": "2021-03-09T21:47:44Z",
          "updatedAt": "2021-03-09T21:47:44Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we can close this now that some issuance protocols admit public metadata.",
          "createdAt": "2022-02-09T22:59:16Z",
          "updatedAt": "2022-02-09T22:59:16Z"
        }
      ]
    },
    {
      "number": 65,
      "id": "MDU6SXNzdWU4MjYxNTE5ODE=",
      "title": "Update Privacy Calculations in Architecture Document",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/65",
      "state": "OPEN",
      "author": "dvorak42",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "The privacy calculations should be updated to take into account metadata more explicitly, and take into account the cost of the number of redemptions, rather than the global issuer count.\r\n\r\nIf used in a multiple disjoint architecture ecosystem, then the math should also be taken in terms of a specific 'context' rather than treating the whole PrivacyPass ecosystem as a single global system (allowing for more nuanced requirements/limitations on issuer counts).",
      "createdAt": "2021-03-09T15:59:47Z",
      "updatedAt": "2022-02-09T22:58:48Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 66,
      "id": "MDU6SXNzdWU4MzAzMTcxMjU=",
      "title": "Add redemption contexts",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/66",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "dvorak42"
      ],
      "labels": [],
      "body": "As discussed during IETF 110, the architecture document should provide guidance on how redemption contexts can be used and how they impact privacy. This is a bit of the calculus we don't yet have.\r\n\r\ncc @dvorak42, @alxdavids ",
      "createdAt": "2021-03-12T17:28:51Z",
      "updatedAt": "2021-07-09T15:09:59Z",
      "closedAt": "2021-07-09T15:09:59Z",
      "comments": [
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, this likely needs to be embedded both into the Architecture draft for the generic concept of a context, and then an actual instantiation of redemption contexts in the HTTP API doc.",
          "createdAt": "2021-03-12T17:35:43Z",
          "updatedAt": "2021-03-12T17:35:43Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep \ud83d\udc4d should we split out the HTTP work into a separate issue?",
          "createdAt": "2021-03-12T18:01:58Z",
          "updatedAt": "2021-03-12T18:01:58Z"
        }
      ]
    },
    {
      "number": 67,
      "id": "MDU6SXNzdWU4NDkzMTk3NzE=",
      "title": "Refactoring the redemption flow",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/67",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Currently, RedemptionRequest messages have the following structure:\r\n\r\n```\r\nstruct {\r\n  opaque data<1..2^16-1>; // input to the token issuance flow\r\n  opaque tag<1..2^16-1>;  // output of the token issuance flow\r\n  opaque info<1..2^16-1>; // application information bound to the token\r\n} RedemptionRequest;\r\n```\r\n\r\nThis has a couple of interesting properties. First, anyone with access to `data` can replay it in the issuance flow and compute `tag`. We might be able to address that by making the redemption flow a two round protocol, similar to what we've done for the issuance flow, or by allowing clients to encrypt `data` under the redeemer's public key. Or something else entirely.\r\n\r\nSecond, `tag` effectively authenticates `info`. Is there any reason why we couldn't merge these two fields and encrypt the latter with an AEAD? And if we were to do that, perhaps we could simplify the redemption interface and have it produce a secret that applications use as needed? Specifically, the `Redeem` function might return a secret rather than a `RedemptionRequest`. Turning the redemption API into an Export-like interface might help accommodate different application use cases.\r\n\r\ncc @armfazh, @siyengar, @dvorak42",
      "createdAt": "2021-04-02T16:21:56Z",
      "updatedAt": "2021-12-17T13:20:26Z",
      "closedAt": "2021-12-17T13:20:26Z",
      "comments": [
        {
          "author": "siyengar",
          "authorAssociation": "NONE",
          "body": "I was actually thinking that since associating tag with info doesn't seem to solve a real problem, we could simplify this by just sending the token and unblinded voprf output without needing an info field to be involved in the first place.",
          "createdAt": "2021-04-02T20:59:08Z",
          "updatedAt": "2021-04-02T20:59:21Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I was actually thinking that since associating tag with info doesn't seem to solve a real problem\r\n\r\nThis is the part I don't quite understand. The `tag` _is_ the VOPRF output. It's proof that the client previously went through the issuance flow with the server given input `data`. (The current draft's usage of the VOPRF API is out of date.) ",
          "createdAt": "2021-04-02T21:02:36Z",
          "updatedAt": "2021-04-02T21:02:36Z"
        },
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "Rather, the VOPRF spec has the output as a binding of the token itself with the unblinded token. I think to get the behavior you want here, the PrivacyPass spec should indicate that the input into the Redeem API can just be the empty string when not used, or just remove the info parameter complretely from Redeem and pass the empty string into the VOPRF Finalize API.",
          "createdAt": "2021-04-02T21:08:25Z",
          "updatedAt": "2021-04-02T21:08:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think to get the behavior you want here, the PrivacyPass spec should indicate that the input into the Redeem API can just be the empty string when not used, or just remove the info parameter complretely from Redeem and pass the empty string into the VOPRF Finalize API.\r\n\r\nThis seems to be the crux of the issue here: `info` is no longer present in the VOPRF Finalize API :-)\r\n\r\nSo we can probably drop it from Redeem, and have the token output be returned (as proposed above). This is separate from whether or not we need to account for replay attacks on the token `input` with two rounds or encryption, I think.",
          "createdAt": "2021-04-02T21:10:06Z",
          "updatedAt": "2021-04-02T21:10:06Z"
        },
        {
          "author": "siyengar",
          "authorAssociation": "NONE",
          "body": "Ya sorry the last statement was a bit confusing.\r\n\r\nYa I think you're right, getting rid of info should solve the problem. And then call it VOPRF_output rather than a tag.\r\n\r\nIt seems like these 2 apis are out of sync \r\n\r\nhttps://cfrg.github.io/draft-irtf-cfrg-voprf/draft-irtf-cfrg-voprf.html#name-finalize\r\nFinalize(input, blind, evaluatedElement)\r\n\r\nhttps://ietf-wg-privacypass.github.io/base-drafts/draft-ietf-privacypass-protocol.html#name-redeem-2\r\nFinalize(token.data, token.issued, info)\r\n\r\n\r\n\r\n",
          "createdAt": "2021-04-05T20:18:59Z",
          "updatedAt": "2021-04-05T20:18:59Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "MDU6SXNzdWU4OTQ0MTg4MDM=",
      "title": "RFC8446 vector syntax is used incorrectly",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/68",
      "state": "CLOSED",
      "author": "tgr",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The [Data structures section](https://github.com/ietf-wg-privacypass/base-drafts/blob/master/draft-ietf-privacypass-protocol.md#data-structures-pp-structs) of the protocol draft says *\"data structures ... are written in the TLS presentation language (RFC8446)\"*. Per [RFC8446 3.4](https://datatracker.ietf.org/doc/html/rfc8446#section-3.4),  vectors are defined as `<item type> <vector type>[n]` where n is the length of the vector in **bytes**. (*\"In either case, the length declares the number of bytes, not the number of elements, in the vector.\"*) In the draft, though, the length is specified by number of items, not number of bytes.",
      "createdAt": "2021-05-18T14:01:33Z",
      "updatedAt": "2021-07-09T15:09:50Z",
      "closedAt": "2021-07-09T15:09:50Z",
      "comments": []
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWU5MDM3NDk1ODA=",
      "title": "Redemption is not working at all",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/69",
      "state": "CLOSED",
      "author": "TsukiZero",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Neither for hCaptcha nor for Cloudflare",
      "createdAt": "2021-05-27T13:26:28Z",
      "updatedAt": "2021-05-31T14:30:47Z",
      "closedAt": "2021-05-31T14:30:47Z",
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "This project isn't linked to https://github.com/privacypass/challenge-bypass-extension, please post an issue there.",
          "createdAt": "2021-05-31T14:30:47Z",
          "updatedAt": "2021-05-31T14:30:47Z"
        }
      ]
    },
    {
      "number": 77,
      "id": "MDU6SXNzdWU5NDA3OTcwNjI=",
      "title": "Pin protocol messages to underlying cryptographic scheme",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/77",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [],
      "body": "Protocols like VOPRF and blind RSA/BLS have different semantics and wire images. As an example, batching seems to be a per-crypto-protocol property. VOPRF supports it, whereas BLS/RSA do not.\r\n\r\nTrying to map these to a shared wire format seems a bit awkward. I recommend we parameterize all PP protocol messages based on the underlying cryptographic construction. So, for example:\r\n\r\n```\r\nenum {\r\n\tVOPRF,\r\n\tBlindRSA,\r\n} Protocol;\r\n\r\nstruct {\r\n\tProtocol proto;\r\n\tuint16 length; // allows skipping over unknown protocols\r\n\tselect (proto) {\r\n\t\tcase VOPRF:\r\n\t\t\topaque blind_elements<1..2^16-1>;\r\n  \t\tcase BlindRSA:\r\n  \t\t\topaque blinded_msg[kLen];\r\n\t}\r\n} IssuanceRequest;\r\n\r\nstruct {\r\n\tProtocol proto;\r\n\tuint16 length; // allows skipping over unknown protocols\r\n\tselect (proto) {\r\n\t\tcase VOPRF:\r\n\t\t\tIssuedToken tokens[m];\r\n  \t\t\topaque proof<1..2^16-1>;\r\n  \t\tcase BlindRSA:\r\n  \t\t\topaque blind_sig[kLen];\r\n\t}\r\n} IssuanceResponse;\r\n```\r\n\r\n(The same should probably apply to redemption messages as well.)\r\n\r\nWe can then refactor the document to only specify how these protocol messages are constructed and parsed, rather than specify how implementation-specific details should work.",
      "createdAt": "2021-07-09T14:05:22Z",
      "updatedAt": "2021-12-17T13:20:52Z",
      "closedAt": "2021-12-17T13:20:52Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as overcome by events.",
          "createdAt": "2021-12-17T13:20:52Z",
          "updatedAt": "2021-12-17T13:20:52Z"
        }
      ]
    },
    {
      "number": 80,
      "id": "MDU6SXNzdWU5NTQyMzEwMTY=",
      "title": "Redemption -> Verify?",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/80",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We currently have two sub-protocols: Issuance and Redemption. Redemption effectively gives the Privacy Pass token to someone else to verify using whatever is the underlying cryptographic protocol. Should we redefine Redemption as such? In particular, imagine we had a sub-protocol called `Verify`, which may or may not be interactive depending on the underlying cryptographic protocol. Redemption could then simply be:\r\n\r\n- Reveal token to the relying party\r\n- Relying party runs Verify\r\n\r\nWe might even consider punting the reveal step to the protocol wrapping Privacy Pass. The fact that tokens change hands before verification _seems_ external to the protocol. ",
      "createdAt": "2021-07-27T20:13:02Z",
      "updatedAt": "2021-12-17T13:20:40Z",
      "closedAt": "2021-12-17T13:20:39Z",
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as overcome by events.",
          "createdAt": "2021-12-17T13:20:39Z",
          "updatedAt": "2021-12-17T13:20:39Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDODeTEy85BCbEM",
      "title": "0x170DBdd337bA421fED5498279a61db29B66aB37d",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/89",
      "state": "CLOSED",
      "author": "phyo734",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "0x170DBdd337bA421fED5498279a61db29B66aB37d\r\n\r\n_Originally posted by @phyo734 in https://github.com/ietf-wg-privacypass/base-drafts/issues/2#issuecomment-1003064394_",
      "createdAt": "2021-12-30T14:58:25Z",
      "updatedAt": "2021-12-30T18:31:51Z",
      "closedAt": "2021-12-30T18:31:51Z",
      "comments": []
    },
    {
      "number": 90,
      "id": "I_kwDODeTEy85CwDs-",
      "title": "Expand upon correlation attacks and mitigations",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/90",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "architecture"
      ],
      "body": "In the architecture document, we should have more discussion of correlation attacks and ways to mitigate. For example, interactive vs non-interactive tokens can making timing correlation attacks more or less relevant. For mitigations, the deployment model of issuer/origin (and attester) can make a difference.",
      "createdAt": "2022-01-31T20:22:24Z",
      "updatedAt": "2022-03-05T16:49:12Z",
      "closedAt": "2022-03-05T16:49:12Z",
      "comments": []
    },
    {
      "number": 93,
      "id": "I_kwDODeTEy85DCLrG",
      "title": "Add issuance test vectors",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/93",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "protocol"
      ],
      "body": "These test vectors should cover the whole flow of the protocol, starting with the `TokenChallenge` input and producing a `Token` output.",
      "createdAt": "2022-02-04T21:46:44Z",
      "updatedAt": "2022-03-07T15:27:08Z",
      "closedAt": "2022-03-07T15:27:08Z",
      "comments": []
    },
    {
      "number": 95,
      "id": "I_kwDODeTEy85DC-wf",
      "title": "youtube",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/95",
      "state": "CLOSED",
      "author": "jheng21",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "m.me/AgentJenny143",
      "createdAt": "2022-02-05T06:56:48Z",
      "updatedAt": "2022-02-05T16:54:17Z",
      "closedAt": "2022-02-05T16:54:17Z",
      "comments": []
    },
    {
      "number": 96,
      "id": "I_kwDODeTEy85DI5H9",
      "title": "HTTP examples",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/96",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "protocol"
      ],
      "body": "See [Mark's original issue](https://github.com/tfpauly/privacy-proxy/issues/160#issue-1125596987).",
      "createdAt": "2022-02-07T19:26:59Z",
      "updatedAt": "2022-03-02T17:11:12Z",
      "closedAt": "2022-03-02T17:11:12Z",
      "comments": []
    },
    {
      "number": 98,
      "id": "I_kwDODeTEy85Dd-X7",
      "title": "https://support.google.com/youtube/thread/149769645?hl=en",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/98",
      "state": "CLOSED",
      "author": "jheng21",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://discord.gg/SVNV8Rv2",
      "createdAt": "2022-02-11T07:09:05Z",
      "updatedAt": "2022-02-11T12:17:49Z",
      "closedAt": "2022-02-11T12:17:49Z",
      "comments": []
    },
    {
      "number": 102,
      "id": "I_kwDODeTEy85FjQc4",
      "title": "Challenge and cookie cache",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/102",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "auth-scheme"
      ],
      "body": "From: https://github.com/tfpauly/privacy-proxy/issues/105\r\n\r\n@chris-wood said:\r\n> Servers can offer multiple challenges in a WWW-Authenticate header to let the client fetch a pile of tokens for future spending. For tracking reasons, the lifetime of these should be bound to any cookie state associated with the origin. In particular, if the client wipes its cookies for the origin, then it should also clear any challenge state. It's possible for the server to encode client-specific information in the TokenChallenge.redemption_nonce, so we need to ensure this doesn't turn into a different type of tracking vector.",
      "createdAt": "2022-03-11T21:03:43Z",
      "updatedAt": "2022-03-15T20:15:16Z",
      "closedAt": "2022-03-15T20:15:16Z",
      "comments": []
    },
    {
      "number": 103,
      "id": "I_kwDODeTEy85FjYzH",
      "title": "Rename redemption_nonce to redemption_context",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/103",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "auth-scheme"
      ],
      "body": "We should consider renaming `redemption_nonce` to `redemption_context`. This value doesn't need to be a nonce, it's just some origin-selected context that it is binding to.\r\n\r\nWe can also rename the `context` in the Token struct to `challenge_digest` to make it clear what role it has.",
      "createdAt": "2022-03-11T21:43:38Z",
      "updatedAt": "2022-03-14T18:08:37Z",
      "closedAt": "2022-03-14T18:08:37Z",
      "comments": []
    },
    {
      "number": 104,
      "id": "I_kwDODeTEy85FjZAX",
      "title": "Per-origin and cross-origin implications on double spend state",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/104",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "chris-wood"
      ],
      "labels": [
        "architecture",
        "auth-scheme"
      ],
      "body": "Origins currently choose whether their challenges are per-origin or cross-origin. For cross-origin, double-spend prevention is only as good as the coordination between origins and the Issuer. Per-origin allows double-spend prevention to be isolated to a single origin; also prevents the cache of tokens being take up by some other origin.",
      "createdAt": "2022-03-11T21:44:52Z",
      "updatedAt": "2022-03-14T18:08:29Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 108,
      "id": "I_kwDODeTEy85GTRJb",
      "title": "Consider including multiple origin names in TokenChallenge",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/108",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "auth-scheme"
      ],
      "body": "From Ted Hardie in Vienna.",
      "createdAt": "2022-03-24T12:35:11Z",
      "updatedAt": "2022-03-30T21:33:59Z",
      "closedAt": "2022-03-30T21:33:59Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "We should also clarify more explicitly how the client uses the origin name field for validating the context it is in.",
          "createdAt": "2022-03-28T19:13:23Z",
          "updatedAt": "2022-03-28T19:13:23Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Leaning towards allowing the `origin_name` being able to be a list of hostnames, with comma separation.",
          "createdAt": "2022-03-28T19:17:13Z",
          "updatedAt": "2022-03-28T19:17:13Z"
        },
        {
          "author": "smhendrickson",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+1 to csv. We think this keeps the client impl's simple while allowing for the added flexibility of origin sets.",
          "createdAt": "2022-03-28T19:17:52Z",
          "updatedAt": "2022-03-28T19:17:52Z"
        },
        {
          "author": "richsalz",
          "authorAssociation": "NONE",
          "body": "Might also have to say something about ignoring whitespace `a,b` vs `a, b` and then maybe just whitespace is the separator?\r\n",
          "createdAt": "2022-03-28T19:23:50Z",
          "updatedAt": "2022-03-28T19:23:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "While I can understand the appeal, I'm not yet convinced we should do this until we have a use case and have thought through the possible privacy impacts.",
          "createdAt": "2022-03-28T19:24:56Z",
          "updatedAt": "2022-03-28T19:24:56Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "I_kwDODeTEy85HEA9B",
      "title": "Look at greasing Client / Origin interactions",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/113",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "auth-scheme"
      ],
      "body": "Origins can issue challenges for greased token types, etc, to ensure client can handle new types in the future.",
      "createdAt": "2022-04-04T19:44:20Z",
      "updatedAt": "2022-04-11T19:20:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "One type of greasing might be adding random authentication credentials to the `Authorization` header, e.g., `Authorization: PrivacyToken foo=bar token=blah bar=baz`.",
          "createdAt": "2022-04-11T19:20:06Z",
          "updatedAt": "2022-04-11T19:20:06Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "I_kwDODeTEy85HiYWM",
      "title": "Don't require padding for base64url?",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/117",
      "state": "OPEN",
      "author": "punkeel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I would like to challenge the following snippet in the RFC, especially the use of the word **MUST**.\r\n> \"challenge\", which contains a base64url-encoded {{!RFC4648}} TokenChallenge value. **Since the length of the challenge is not fixed, the base64url data MUST include padding.**\r\n\r\nBase 64 decoding does not require the padding to get the *exact* encoded value, bit-for-bit.\r\n\r\nFrom what I understand, issues arise when it's impossible to know the length of the encoded base64 payload, due to lack of delimiters. eg, if we encode `hello` and `world`, then concat them (without padding), this gives us:\r\n`aGVsbG8=` + `d29ybGQ=` == `aGVsbG8d29ybGQ` ==> `hello.\u00db\u00dc..`\r\n\r\nWhen the base64 length is fully known (thanks to delimiters like space or line breaks), this is a non-issue.\r\n\r\n\r\nMay I recommend that clients instead **MUST support** base64url encoding with and without padding?",
      "createdAt": "2022-04-11T16:05:57Z",
      "updatedAt": "2022-04-18T22:14:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for filing @punkeel! There's a couple reasons why we went with padding. First, padding seems to be the default encoding for most [many](https://docs.rs/base64/latest/base64/index.html) [base64](https://pkg.go.dev/encoding/base64) [implementations](https://source.chromium.org/chromium/chromium/src/+/main:base/base64url.h). Second, as you point out, no padding is an issue without a known length, so this would require us to specify that length in order to help clients parse things correctly. That pushes complexity into the protocol. Putting these together, allowing unpadded base64 would just force all clients to implement a thing that's not really needed while also making the protocol more complex, so it didn't seem worth the flexibility. ",
          "createdAt": "2022-04-18T22:10:49Z",
          "updatedAt": "2022-04-18T22:10:49Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "There's also a desire amongst the authors to keep the supported cases be stricter and more limited to avoid interop problems.\r\n\r\nThe question I have is who benefits by allowing the specification to be loose here in allowing both forms in both directions?",
          "createdAt": "2022-04-18T22:14:41Z",
          "updatedAt": "2022-04-18T22:14:41Z"
        }
      ]
    },
    {
      "number": 118,
      "id": "I_kwDODeTEy85HjP_Z",
      "title": "Explain consequences of using publicly verifiable token",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/118",
      "state": "OPEN",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "The publicly verifiable basic token issuance protocol doesn't include an origin name that the issuer can see, so it does allow origins to be able to use that issuer (as long as the know the key) without explicit coordination or permission from the issuer. This isn't necessarily a problem, but we should likely mention it.",
      "createdAt": "2022-04-11T19:16:46Z",
      "updatedAt": "2022-04-11T19:16:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 119,
      "id": "I_kwDODeTEy85IDmIs",
      "title": "Forgery definition",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/119",
      "state": "OPEN",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "We current state this as the requirement:\r\n\r\n> One-more forgery security. The issuance protocol MUST NOT allow malicious Clients or Attesters (acting as Clients) to forge tokens without interacting with the Issuer directly.\r\n\r\nThis could be misread in that we do allow forgeries when interacting with the Issuer directly. Clearly that's not the intent, so let's fix this.",
      "createdAt": "2022-04-19T22:01:29Z",
      "updatedAt": "2022-04-19T22:01:42Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 120,
      "id": "I_kwDODeTEy85INv6T",
      "title": "Blind RSA identifier ",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/120",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The SPKI format is currently unspecified, and as there are multiple ways to encode an RSA public key (and hash algorithm), this makes interop somewhat difficult. Moreover, the SPKI can encode any number of RSA public key sizes, in contrast to elliptic curves wherein the \"suite\" typically defines the key size. In the name of simplicity, I'd propose that we have the identifier fully specify everything one needs to use the algorithm, including key size, hash algorithm, and encoding format.",
      "createdAt": "2022-04-21T21:19:33Z",
      "updatedAt": "2022-04-26T02:55:11Z",
      "closedAt": "2022-04-26T02:55:11Z",
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Clarified that this would mean that each token type fully specifies the algorithms and sizes it uses. I support this.",
          "createdAt": "2022-04-21T21:42:55Z",
          "updatedAt": "2022-04-21T21:42:55Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Right, specifically, I think each type would specify:\r\n\r\n1. Hash algorithm\r\n2. Public key (and signature) size\r\n3. Public key encoding\r\n\r\nThere's a large number of permutations here, e.g.,\r\n\r\n- SHA-256, 4096-bit key, RSASSA-PSS OID SPKI\r\n- SHA-256, 2048-bit key, RSASSA-PSS OID SPKI\r\n- ...\r\n\r\n",
          "createdAt": "2022-04-22T15:03:06Z",
          "updatedAt": "2022-04-22T15:05:07Z"
        }
      ]
    },
    {
      "number": 121,
      "id": "I_kwDODeTEy85IOS84",
      "title": "Clearly explain least significant byte in key_id",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/issues/121",
      "state": "CLOSED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "We should be explicit about what this means:\r\n\r\n`\"token_key_id\" is the least significant byte of the key_id.`\r\n\r\nThis means that the byte is the last/rightmost byte of the hash, in order. Misinterpretation of this caused some confusion in interop.",
      "createdAt": "2022-04-22T01:22:15Z",
      "updatedAt": "2022-04-26T02:47:20Z",
      "closedAt": "2022-04-26T02:47:20Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyNDY0NDMx",
      "title": "Initial HTTP API Draft",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/1",
      "state": "MERGED",
      "author": "dvorak42",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a basic draft for the HTTP API, it still needs work to bring it into sync with the architecture doc (and to fill out some of the registry/storage sections).\r\n\r\nWill keep on iterating on it, but wanted to make the PR so people can start looking at it/responding to it, and also to figure out which bits should be in this doc versus the other PrivacyPass docs.",
      "createdAt": "2020-03-02T15:57:39Z",
      "updatedAt": "2020-03-04T17:35:24Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "a8e6ed43f5863a50ad36949c4d9cae3a1e315d74",
      "headRepository": "dvorak42/privacy-pass-ietf",
      "headRefName": "master",
      "headRefOid": "46cb0fb4756d625b7bb07da9e5e904c24aa01327",
      "closedAt": "2020-03-04T17:35:24Z",
      "mergedAt": "2020-03-04T17:35:24Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "43e828c9f5535d81cd1a316972ebf3ee689f37e5"
      },
      "comments": [
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "Added a section about the global registry.",
          "createdAt": "2020-03-03T15:55:01Z",
          "updatedAt": "2020-03-03T15:55:01Z"
        },
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I think there's now enough meet on this to merge it as is, and I can make additional PRs to update it/clean it up. ",
          "createdAt": "2020-03-04T14:58:16Z",
          "updatedAt": "2020-03-04T14:58:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3OTE3NDgx",
          "commit": {
            "abbreviatedOid": "45855ed"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This LGTM so far, I just have a few small comments. We can probably look at merging this once we have more detail about the commitment registry.",
          "createdAt": "2020-03-03T11:56:18Z",
          "updatedAt": "2020-03-03T11:59:51Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "This is probably hangover from draft-privacy-pass, but we should remove mention of VOPRFs to be as generic as possible",
              "createdAt": "2020-03-03T11:56:18Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            },
            {
              "originalPosition": 242,
              "body": "I guess that this should be `i_data`?",
              "createdAt": "2020-03-03T11:57:05Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            },
            {
              "originalPosition": 263,
              "body": "This is slightly different to how the SERVER_ISSUE interface currently operates, as it this interface that calls CLIENT_ISSUE_FINISH. Perhaps the interface should be modified so that SERVER_ISSUE returns the response to CLIENT_ISSUE_GEN to match what you have here?",
              "createdAt": "2020-03-03T11:57:41Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            },
            {
              "originalPosition": 287,
              "body": "Eventually we may want to be more prescriptive about how additional_data is formed as it is the HMAC input. This document may be the best place to do that.",
              "createdAt": "2020-03-03T11:58:10Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MDQyMTMz",
          "commit": {
            "abbreviatedOid": "45855ed"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-03T14:49:58Z",
          "updatedAt": "2020-03-03T14:49:58Z",
          "comments": [
            {
              "originalPosition": 263,
              "body": "Yeah, was going to comment on the architecture doc, in that for some of the interfaces its a bit odd that they internally call back and forth between the server and client, which makes it hard to integrate at the communication between the two.\r\n\r\nOne potential change is making them return these intermediate responses which are then used as inputs to the matching side, and optionally having interfaces that encapsulate the whole flow, so that APIs built on top of them can integrate between the individual steps rather than needing to redefine how they internally call back and forth.\r\n\r\n",
              "createdAt": "2020-03-03T14:49:58Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MDQ0NjU5",
          "commit": {
            "abbreviatedOid": "45855ed"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-03T14:52:46Z",
          "updatedAt": "2020-03-03T14:52:46Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Ah yeah, synced with a previous copy of the protocol doc, updated.",
              "createdAt": "2020-03-03T14:52:46Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4MDU3MjU4",
          "commit": {
            "abbreviatedOid": "45855ed"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-03T15:06:59Z",
          "updatedAt": "2020-03-03T15:07:00Z",
          "comments": [
            {
              "originalPosition": 287,
              "body": "Specific construction for the delegated case is down below, but I'm not sure whether the client (UA) which originally has the tokens should be doing PP_Redeem and then passing the result of that to whatever website wants to redeem a token (allowing the UA to set the aux additional_data, so that it can't be reused elsewhere), or whether the website should be taking the raw token and doing its own PP_Redeem with whatever it wants to insert in aux.",
              "createdAt": "2020-03-03T15:06:59Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTkyMjIy",
          "commit": {
            "abbreviatedOid": "9ad2faf"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T08:47:20Z",
          "updatedAt": "2020-03-04T08:47:20Z",
          "comments": [
            {
              "originalPosition": 263,
              "body": "Yeah rewriting the interfaces to return those values synchronously to the calling interface makes sense. I'll write up the change.",
              "createdAt": "2020-03-04T08:47:20Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NTk4NDE2",
          "commit": {
            "abbreviatedOid": "9ad2faf"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "A few comments. I think this currently serves as a good starting point. I plan to send some calls for participation around soon, linking to the WIP docs that we currently have. If you would be happy with it, then we could merge this draft in its current state and then continue to iterate on top of it?",
          "createdAt": "2020-03-04T08:57:17Z",
          "updatedAt": "2020-03-04T09:01:40Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "Can also provide a link to the architecture document here for more details.",
              "createdAt": "2020-03-04T08:57:18Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            },
            {
              "originalPosition": 56,
              "body": "This isn't present in the architecture document but I think it's a good idea to make verification easier. I guess the proof is updated every time the commitment is updated?",
              "createdAt": "2020-03-04T08:59:03Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODQ2OTk1",
          "commit": {
            "abbreviatedOid": "9ad2faf"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-04T14:57:04Z",
          "updatedAt": "2020-03-04T14:57:05Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "Yeah, wasn't sure if using a system that supports an inclusion proof should be part of the main architecture doc or for specific instantiations of Privacy Pass. But yeah, you'd get a new inclusion proof when you do the commitment (probably some update to the GLOBAL_CONFIG_UPDATE interface to support this).",
              "createdAt": "2020-03-04T14:57:04Z",
              "updatedAt": "2020-03-04T14:57:22Z"
            }
          ]
        }
      ]
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg0ODQ4MzMy",
      "title": "Fixing draft formatting",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/4",
      "state": "MERGED",
      "author": "dvorak42",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-06T14:25:05Z",
      "updatedAt": "2020-03-06T14:58:46Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "19581ad111f8feb11d3e3f9a1762d29830aa86e0",
      "headRepository": "dvorak42/privacy-pass-ietf",
      "headRefName": "master",
      "headRefOid": "8048b7a35d1071283ebd7213b8af0ff95bb8427a",
      "closedAt": "2020-03-06T14:58:46Z",
      "mergedAt": "2020-03-06T14:58:46Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "e006b84a4b5ddd9bcd9e939a25dbb0d8ee775692"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzg0MTQy",
          "commit": {
            "abbreviatedOid": "8048b7a"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-03-06T14:58:40Z",
          "updatedAt": "2020-03-06T14:58:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg5NDI5NDM1",
      "title": "Fix #5: reorg repo",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/6",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Borrow repo structure from https://github.com/quicwg/base-drafts/ as per #5.",
      "createdAt": "2020-03-16T18:37:42Z",
      "updatedAt": "2020-03-16T18:38:50Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "7be7f305a4620f5c15814d46f90ea9d2b6ddd7be",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/repo-structure",
      "headRefOid": "69984936b26be5710f7551296202b209dd5be73f",
      "closedAt": "2020-03-16T18:38:49Z",
      "mergedAt": "2020-03-16T18:38:49Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "caa104150bd8c21f8347a301db271560a3095b62"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 7,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkzMzg4MTUz",
      "title": "Solve some consistency problems",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/7",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-03-25T05:12:43Z",
      "updatedAt": "2020-05-11T12:58:46Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "d220f993d1a2c6dbca62eb8f70af52918ea2080b",
      "headRepository": "claucece/privacy-pass-ietf",
      "headRefName": "master",
      "headRefOid": "39e4a985ab716eb7bfa28792d194fc9242089fec",
      "closedAt": "2020-05-11T12:58:46Z",
      "mergedAt": "2020-05-11T12:58:46Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "e17c69355a47bd4354d6ea23bf54cf43edec9bca"
      },
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just fixed them all ;)",
          "createdAt": "2020-04-14T07:49:01Z",
          "updatedAt": "2020-04-14T07:49:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMTg4NjUx",
          "commit": {
            "abbreviatedOid": "ed5352d"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Thanks for these changes, just a few amendments from my side.",
          "createdAt": "2020-04-13T14:43:18Z",
          "updatedAt": "2020-04-13T14:49:04Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I think the word `encounter` can be removed here.",
              "createdAt": "2020-04-13T14:43:18Z",
              "updatedAt": "2020-04-14T07:45:49Z"
            },
            {
              "originalPosition": 134,
              "body": "`received from a server`?",
              "createdAt": "2020-04-13T14:43:50Z",
              "updatedAt": "2020-04-14T07:45:49Z"
            },
            {
              "originalPosition": 392,
              "body": "requires minor rewording, perhaps: \r\n```\r\nError occurred when a client attempts to verify the proof...\r\n```",
              "createdAt": "2020-04-13T14:46:21Z",
              "updatedAt": "2020-04-14T07:45:49Z"
            },
            {
              "originalPosition": 419,
              "body": "`perform` -> `performs`",
              "createdAt": "2020-04-13T14:46:40Z",
              "updatedAt": "2020-04-14T07:45:49Z"
            },
            {
              "originalPosition": 421,
              "body": "`doing is` -> `doing this is`\r\n(already existing typo)",
              "createdAt": "2020-04-13T14:46:58Z",
              "updatedAt": "2020-04-14T07:45:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MTQ2NTE2",
          "commit": {
            "abbreviatedOid": "39e4a98"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-11T12:58:35Z",
          "updatedAt": "2020-05-11T12:58:35Z",
          "comments": []
        }
      ]
    },
    {
      "number": 12,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA2NzI1NzIz",
      "title": "Updated charter text",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/12",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Changes account for feedback received during (and following) virtual BoF session, including:\r\n\r\n- Scoping protocol to application-layer.\r\n- Considering the case of transferable tokens only.\r\n- Specific points to consider potential consolidation/trust issues.\r\n- Not committing to a specific set of documents.\r\n- Ensuring that Clients can verify Issuer key material.\r\n",
      "createdAt": "2020-04-21T14:51:04Z",
      "updatedAt": "2020-05-14T16:51:43Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "d220f993d1a2c6dbca62eb8f70af52918ea2080b",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "post-bof-charter",
      "headRefOid": "24e38dc0f0130cb7cf5fb72704c3ca1b1e408c4c",
      "closedAt": "2020-05-14T16:51:43Z",
      "mergedAt": "2020-05-14T16:51:43Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "bf7e53ab85bd05f6a776dde433eda0b2417a39f9"
      },
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Going to merge this now so that we have a working up-to-date version. Further changes can be made in a new PR.",
          "createdAt": "2020-05-14T16:51:38Z",
          "updatedAt": "2020-05-14T16:51:38Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0NDEzNzkxMjky",
      "title": "Rename some fields and fix some nits",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/19",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Rename IssuanceMessage and RedemptionMessage to IssuanceRequest and RedemptionRequest, respectively. Rename SecretKey to PrivateKey. Change `max_evals` to an integer value, rather than opaque vector.\r\n\r\nI also removed company-specific information, which is not really relevant for the document. (That's useful information, but not appropriate for a standards document, I think.)\r\n\r\ncc @alxdavids @dvorak42 ",
      "createdAt": "2020-05-05T22:50:40Z",
      "updatedAt": "2020-05-20T07:46:52Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "8f89861020ed4d73c2337c1a1905f2fee7714d69",
      "headRepository": "chris-wood/privacy-pass-ietf",
      "headRefName": "caw/nits-and-renaming",
      "headRefOid": "fc8e56ed4af68ca7cbb5f612709f4fd3dcaf1c41",
      "closedAt": "2020-05-20T07:46:52Z",
      "mergedAt": "2020-05-20T07:46:52Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "040a82989fdb41ce30d810a4c6e4a951a8cc08ad"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MjU4NTU2",
          "commit": {
            "abbreviatedOid": "79dfa07"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good, just one thing that needs to change I think.",
          "createdAt": "2020-05-19T09:18:44Z",
          "updatedAt": "2020-05-19T09:20:07Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n\"initialisation\", produces the global server configuration that is\r\n```",
              "createdAt": "2020-05-19T09:18:45Z",
              "updatedAt": "2020-05-19T14:57:55Z"
            },
            {
              "originalPosition": 46,
              "body": "also, existing typo on my part, but maybe it should be initialization?",
              "createdAt": "2020-05-19T09:19:21Z",
              "updatedAt": "2020-05-19T14:57:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1MDczMzMw",
          "commit": {
            "abbreviatedOid": "fc8e56e"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-20T07:46:30Z",
          "updatedAt": "2020-05-20T07:46:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE4Njk5MTQ1",
      "title": "Rename SecretKey to PrivateKey for consistency with PublicKey.",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/25",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #17.",
      "createdAt": "2020-05-15T16:54:24Z",
      "updatedAt": "2020-05-15T17:04:44Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "bf7e53ab85bd05f6a776dde433eda0b2417a39f9",
      "headRepository": "chris-wood/privacy-pass-ietf",
      "headRefName": "caw/rename-secret-key",
      "headRefOid": "41b58addda7ff968aa2c6477ea5eb2de668e1b27",
      "closedAt": "2020-05-15T17:04:44Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 26,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE4NzAzNDc3",
      "title": "Namespace all PrivacyPass routines.",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/26",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "These functions do not need the \"PP_\" namespace prefix as it's implied\r\nfrom the specification. I also removed underscores in favor of normal\r\ncamel case notation.",
      "createdAt": "2020-05-15T17:04:18Z",
      "updatedAt": "2020-05-19T09:17:12Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "bf7e53ab85bd05f6a776dde433eda0b2417a39f9",
      "headRepository": "chris-wood/privacy-pass-ietf",
      "headRefName": "caw/namespace",
      "headRefOid": "72fc5e13e44915cc9fa1eccf890eacb75530817b",
      "closedAt": "2020-05-19T09:17:11Z",
      "mergedAt": "2020-05-19T09:17:11Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "8f89861020ed4d73c2337c1a1905f2fee7714d69"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE0MjU3MDk1",
          "commit": {
            "abbreviatedOid": "72fc5e1"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-19T09:16:52Z",
          "updatedAt": "2020-05-19T09:16:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE5OTg2NTE1",
      "title": "Updates based on 17 May comments",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/27",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-19T09:14:48Z",
      "updatedAt": "2020-05-20T07:43:49Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "bf7e53ab85bd05f6a776dde433eda0b2417a39f9",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/charter-updates",
      "headRefOid": "b7c19fe867913815103ab1bf80f274ea1aba1e22",
      "closedAt": "2020-05-20T07:43:49Z",
      "mergedAt": "2020-05-20T07:43:49Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "037ea9c67c2dbcd0d746eb34d57037796a571260"
      },
      "comments": [
        {
          "author": "jsalowey",
          "authorAssociation": "NONE",
          "body": "I think we should merge this change.",
          "createdAt": "2020-05-20T03:56:51Z",
          "updatedAt": "2020-05-20T03:56:51Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging the change following approvals from the chairs on list.",
          "createdAt": "2020-05-20T07:43:44Z",
          "updatedAt": "2020-05-20T07:43:44Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0NDIwOTYyMDQx",
      "title": "Another take at unlinkability.",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/28",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "And fix some nits.",
      "createdAt": "2020-05-20T19:00:57Z",
      "updatedAt": "2020-05-25T16:11:05Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "040a82989fdb41ce30d810a4c6e4a951a8cc08ad",
      "headRepository": "chris-wood/privacy-pass-ietf",
      "headRefName": "caw/charter-nits",
      "headRefOid": "5558d353bc2fc642cab456052aa0c07f018ca01b",
      "closedAt": "2020-05-25T16:11:05Z",
      "mergedAt": "2020-05-25T16:11:05Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "6a3120e1c6662dc722302fa95010477d349477dc"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Hmm, I think this still needs to say something about keys.\r\n\r\nYeah, good point! ",
          "createdAt": "2020-05-20T19:26:47Z",
          "updatedAt": "2020-05-20T19:26:47Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this clarification is more specific than the previous wording so I'm happy to add it.",
          "createdAt": "2020-05-25T16:10:59Z",
          "updatedAt": "2020-05-25T16:10:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NjM4MzU0",
          "commit": {
            "abbreviatedOid": "5e246aa"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Hmm, I think this still needs to say something about keys.\r\n\r\nIf the issuer issues some users M tokens under key 1 and others L under key 2, you want to say that you can't link them beyond 1/N (where N is either M or L, depending on which key the tokens were issued to).",
          "createdAt": "2020-05-20T19:11:31Z",
          "updatedAt": "2020-05-20T19:15:42Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "*Issuer",
              "createdAt": "2020-05-20T19:11:32Z",
              "updatedAt": "2020-05-20T19:26:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3Nzk2Njg5",
          "commit": {
            "abbreviatedOid": "5558d35"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-05-25T16:09:40Z",
          "updatedAt": "2020-05-25T16:09:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 29,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM0NzEwNzA1",
      "title": "Synchronize charter with datatracker 00-00",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/29",
      "state": "MERGED",
      "author": "kaduk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Before entering the draft charter into the datatracker for IESG+IAB evaluation (https://datatracker.ietf.org/doc/charter-ietf-privacypass/), I made a few edits.  Let's get them in place here as well, to avoid skew in what people see if they look in different places.\r\n\r\nI also put a bit of commentary on the motivation for the changes, at https://github.com/kaduk/privacy-pass-ietf/pull/1/files",
      "createdAt": "2020-06-15T18:47:19Z",
      "updatedAt": "2020-06-17T10:17:32Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "2f726b08a6a11aac1ae5703663abd1e6d49c9dc9",
      "headRepository": "kaduk/privacy-pass-ietf",
      "headRefName": "master",
      "headRefOid": "6a33a911fcdb8ec93dad7b48e42d5b6e0065e717",
      "closedAt": "2020-06-17T10:17:32Z",
      "mergedAt": "2020-06-17T10:17:32Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "b0d666b8fac64a745763f811bfd92a16c5be4576"
      },
      "comments": [
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "+1, looks good.",
          "createdAt": "2020-06-16T14:04:54Z",
          "updatedAt": "2020-06-16T14:04:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMzM4MjQ0",
          "commit": {
            "abbreviatedOid": "6a33a91"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83d\udc4d \r\ncc @dvorak42 to get another review before I merge.",
          "createdAt": "2020-06-16T09:46:41Z",
          "updatedAt": "2020-06-16T09:46:41Z",
          "comments": []
        }
      ]
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQxMzQxNTg2",
      "title": "Update protocol doc for new VOPRF API (fixes #30)",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/31",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Rewrite parts of intro\r\n- Clean up protocol overview\r\n- Rewrite API functions\r\n- Rewrite protocol instantiation\r\n- Update ciphersuites\r\n\r\n(This is a big change, apologies!)\r\n\r\ncc @dvorak42, @chris-wood for reviews (will also notify mailing list).",
      "createdAt": "2020-06-29T11:32:27Z",
      "updatedAt": "2020-07-07T17:28:03Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "b0d666b8fac64a745763f811bfd92a16c5be4576",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/update-protocol",
      "headRefOid": "39988e8de6c1a74abde07af954df8613a69169b8",
      "closedAt": "2020-07-07T17:28:03Z",
      "mergedAt": "2020-07-07T17:28:03Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "dcfe294925fdd8d5f0817d0053eddbfc0b8009d3"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTcyNjQ3",
          "commit": {
            "abbreviatedOid": "35e1d3d"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-07-01T20:24:25Z",
          "updatedAt": "2020-07-06T19:09:53Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Should this be @dvorak42?",
              "createdAt": "2020-07-01T20:24:25Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            },
            {
              "originalPosition": 1033,
              "body": "```suggestion\r\nThe RECOMMENDED Issuer ciphersuites are as follows:\r\n```",
              "createdAt": "2020-07-06T19:08:01Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            },
            {
              "originalPosition": 1033,
              "body": "Probably one of them should be MTI too, right?",
              "createdAt": "2020-07-06T19:08:11Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            },
            {
              "originalPosition": 1064,
              "body": "```suggestion\r\nstatic Diffie Hellman attacks. See {{I-D.irtf-cfrg-voprf}} for more details.\r\n```",
              "createdAt": "2020-07-06T19:08:27Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            },
            {
              "originalPosition": 1118,
              "body": "As we removed the batch interface to Blind, this pseudocode probably needs to be updated.",
              "createdAt": "2020-07-06T19:08:54Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            },
            {
              "originalPosition": 1175,
              "body": "Ditto here for the batch interface.",
              "createdAt": "2020-07-06T19:09:09Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            },
            {
              "originalPosition": 1287,
              "body": "Where did \"OPRF2\" come from?",
              "createdAt": "2020-07-06T19:09:34Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNjcxODQ1",
          "commit": {
            "abbreviatedOid": "35e1d3d"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T08:27:24Z",
          "updatedAt": "2020-07-07T08:31:08Z",
          "comments": [
            {
              "originalPosition": 1033,
              "body": "How is this usually specified?",
              "createdAt": "2020-07-07T08:27:24Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            },
            {
              "originalPosition": 1175,
              "body": "Right, but if we have a batched proof then we'll need to evaluate it over all the evaluated elements at once. I don't think this is will be as easy as pushing it all into the for loop?",
              "createdAt": "2020-07-07T08:29:01Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            },
            {
              "originalPosition": 1287,
              "body": "Due to OPRF ciphersuite with ID=0x0002. I could just call it by its full name, but I thought that it introduced naming redundancy?",
              "createdAt": "2020-07-07T08:29:53Z",
              "updatedAt": "2020-07-07T10:13:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDkwNDk2",
          "commit": {
            "abbreviatedOid": "39988e8"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-07T17:08:57Z",
          "updatedAt": "2020-07-07T17:08:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 32,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQxMzQ1MTI0",
      "title": "Permit additional token metadata (fixes #11)",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/32",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add allowances in protocol doc for redemption metadata\r\n- Provide privacy analysis of including metadata to architecture doc\r\n- Update privacy parametrizations\r\n\r\ncc @dvorak42 @chris-wood @mmaker (I don't know everyone's github usernames, so feel free to add others who will be interested in reviewing).",
      "createdAt": "2020-06-29T11:37:45Z",
      "updatedAt": "2020-07-07T17:29:57Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "dcfe294925fdd8d5f0817d0053eddbfc0b8009d3",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/metadata",
      "headRefOid": "abb6e73183265619f9266df11360fe82eeac8342",
      "closedAt": "2020-07-07T17:29:56Z",
      "mergedAt": "2020-07-07T17:29:56Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "057bb23552fea28152efd9b630b171de3651935d"
      },
      "comments": [
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2020-07-06T19:15:37Z",
          "updatedAt": "2020-07-06T19:15:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzIzMjI1",
          "commit": {
            "abbreviatedOid": "63b11a3"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T16:44:25Z",
          "updatedAt": "2020-06-29T16:52:57Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I'd leave this pointing at the WICG API (the explainer there and the spec, whenever I get around to actually publishing it) is probably the canonical for Trust Token.",
              "createdAt": "2020-06-29T16:44:25Z",
              "updatedAt": "2020-07-07T17:29:10Z"
            },
            {
              "originalPosition": 42,
              "body": "nit: Issuer",
              "createdAt": "2020-06-29T16:44:48Z",
              "updatedAt": "2020-07-07T17:29:10Z"
            },
            {
              "originalPosition": 127,
              "body": "The initial Trust Token experiment actually has log2(6) metadata bits (allowing 3 different keys to be configured at a time for public metadata and 1 bit of private metadata), though stricter allowed issuers per page limits than here. For the purpose of this spec, I'd guess keeping it at 1 metadata bit as an example, rather than using the amounts from Trust Token.",
              "createdAt": "2020-06-29T16:51:33Z",
              "updatedAt": "2020-07-07T17:29:10Z"
            },
            {
              "originalPosition": 24,
              "body": "You sort of get public metadata from the VOPRF construction by allowing for multiple issuance keys at a time. (which is also how it is handled in Trust Token currently)",
              "createdAt": "2020-06-29T16:52:52Z",
              "updatedAt": "2020-07-07T17:29:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMzUwNjg3",
          "commit": {
            "abbreviatedOid": "7bd240a"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM. We\u2019ll need to work through the extensibility support for the metadata bit variant next.",
          "createdAt": "2020-07-06T19:28:43Z",
          "updatedAt": "2020-07-06T19:28:43Z",
          "comments": []
        }
      ]
    },
    {
      "number": 33,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQxNDE3OTI0",
      "title": "Reinforce anonymity requirements and core use-cases",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/33",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add a motivating use-cases section to discuss Tor (#9)\r\n- Add a section to identify what we mean by anonymity (#10)\r\n- Replaced some usages of privacy with anonymity\r\n\r\ncc @chris-wood @dvorak42 @chelseakomlo for feedback",
      "createdAt": "2020-06-29T13:33:39Z",
      "updatedAt": "2020-07-08T09:52:04Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "057bb23552fea28152efd9b630b171de3651935d",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/use-cases",
      "headRefOid": "91323daba8ae15924df0c5e1794387bf3641d3cd",
      "closedAt": "2020-07-08T09:52:03Z",
      "mergedAt": "2020-07-08T09:52:03Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "cd9585cb8deb06d02bcf61309bd65137e8e6922d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MjQzOTgw",
          "commit": {
            "abbreviatedOid": "b1602cf"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2020-06-29T15:11:57Z",
          "updatedAt": "2020-06-29T16:19:13Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "```suggestion\r\nsuch as Tor. In particular, the protocol allows clients to\r\n```\r\n\r\nI don't think a VPN is an anonymity-preserving tool.",
              "createdAt": "2020-06-29T15:11:57Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\n  redeem more than `N` valid tokens.\r\n```",
              "createdAt": "2020-06-29T15:15:05Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\nThe Privacy Pass protocol has a number of use cases in practice. \r\nSee {{DGSTV18}}, {{TrustTokenAPI}}, {{PrivateStorage}}, {{OpenPrivacy}}, \r\nand {{Brave}} for examples.\r\n```",
              "createdAt": "2020-06-29T16:14:57Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 106,
              "body": "```suggestion\r\nWe also require that clients cannot forge tokens, as otherwise Privacy Pass would\r\nhave little value as an authorization protocol. This requirement is stated as follows.\r\n```",
              "createdAt": "2020-06-29T16:16:16Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 103,
              "body": "Focusing on the clients may be overly generic. What if clients were de-anonymized by IP address, for example? Perhaps:\r\n\r\n```suggestion\r\n- A token issued by a server key and subsequently redeemed is indistinguishable from any other \r\n  token issued under the same key.\r\n```",
              "createdAt": "2020-06-29T16:18:32Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 112,
              "body": "```suggestion\r\n{{sec-reqs}} elaborates on these protocol anonymity and security requirements.\r\n```",
              "createdAt": "2020-06-29T16:19:10Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MzMwOTA2",
          "commit": {
            "abbreviatedOid": "b1602cf"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-29T16:54:34Z",
          "updatedAt": "2020-06-29T16:57:54Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Probably pointing at the WICG repo as the canonical one makes sense, though maybe point it at the web.dev post until I get around to updating the WICG with the spec.",
              "createdAt": "2020-06-29T16:54:34Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNDg0MjU0",
          "commit": {
            "abbreviatedOid": "b1602cf"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-03T15:41:18Z",
          "updatedAt": "2020-07-03T15:41:18Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'll change it back, I think what is in the WICG repo works.",
              "createdAt": "2020-07-03T15:41:18Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNDQ5MDAx",
          "commit": {
            "abbreviatedOid": "c60ce8f"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-06T22:35:16Z",
          "updatedAt": "2020-07-06T22:41:06Z",
          "comments": [
            {
              "originalPosition": 80,
              "body": "```suggestion\r\nauthorization of Tor users. In particular, the protocol allows clients to reveal\r\n```",
              "createdAt": "2020-07-06T22:35:16Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nBeyond this use case, the Privacy Pass protocol has a number of use cases in practice. See\r\n```",
              "createdAt": "2020-07-06T22:38:25Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\nPrivacy Pass provides anonymity-preserving authorization tokens for clients. \r\nThroughout this document, we use the terms\r\n```",
              "createdAt": "2020-07-06T22:39:00Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 99,
              "body": "```suggestion\r\nsecurity guarantee of the protocol. Informally, this guarantee means that\r\nany token issued by a server key and subsequently redeemed is indistinguishable \r\nfrom any other token issued under the same key.\r\n```",
              "createdAt": "2020-07-06T22:40:02Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 106,
              "body": "```suggestion\r\nPrivacy Pass also prohibits clients from forging tokens, as otherwise the protocol\r\nwould have little value as an authorization protocol. Informally, this means any client \r\nthat is issued `N` tokens under a given server key cannot redeem more than `N` valid \r\ntokens.\r\n```",
              "createdAt": "2020-07-06T22:41:02Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNDk5NTQ1",
          "commit": {
            "abbreviatedOid": "c60ce8f"
          },
          "author": "chelseakomlo",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks good- overall I would recommend strengthening the intuition of what it means for tokens to be unlinkable (either in this document or where appropriate), as token unlinkability is the technique that achieves the end goal of Privacy Pass, which is indistinguishability of user access patterns to the server. ",
          "createdAt": "2020-07-07T01:18:51Z",
          "updatedAt": "2020-07-07T01:38:13Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Somewhere in the document, it should specify that the anonymity guarantee of Privacy Pass assumes that client IP addresses are either 1) not monitored/stored by the server, even though the client has no mechanism to verify this (otherwise the server can trivially build a lookup table of client IP addresses to the tokens they have used), or 2) an underlying anonymity tool such as Tor is used to hide the client IP address from the server.  ",
              "createdAt": "2020-07-07T01:18:51Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 99,
              "body": "Importantly, of course, this also requires that all clients are issued tokens under the same key for the same epoch when the key is valid (thereby actually ensuring the global anonymity set). ",
              "createdAt": "2020-07-07T01:27:12Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            },
            {
              "originalPosition": 119,
              "body": "And of course that clients have a mechanism to verify their view of the Issuer public key is the same as all other clients.",
              "createdAt": "2020-07-07T01:30:17Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzY0Njg1",
          "commit": {
            "abbreviatedOid": "7fbd61a"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T10:30:48Z",
          "updatedAt": "2020-07-07T10:30:49Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "That's a good point, I've added a subsection to the assumptions we make on the Client as part of the ecosystem to discuss this.",
              "createdAt": "2020-07-07T10:30:48Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzY0ODky",
          "commit": {
            "abbreviatedOid": "7fbd61a"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T10:31:08Z",
          "updatedAt": "2020-07-07T10:31:08Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "Added a link to the discussion about this in the architecture doc.",
              "createdAt": "2020-07-07T10:31:08Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MTI3MTE0",
          "commit": {
            "abbreviatedOid": "4150b83"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T18:00:05Z",
          "updatedAt": "2020-07-07T18:00:06Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n### Client identifying information {#client-ip}\r\n\r\nPrivacy properties of this protocol do not take into account other possibly identifying\r\ninformation available in an implementation, such as a client's IP address. Servers\r\nwhich monitor IP addresses may use this to track client redemption patterns over\r\ntime. Clients cannot check whether servers monitor such identifying information.\r\nThus, clients SHOULD minimize or remove identifying information where possible,\r\ne.g., by using anonymity-preserving tools such as Tor to interact with Servers.\r\n```",
              "createdAt": "2020-07-07T18:00:05Z",
              "updatedAt": "2020-07-08T09:49:33Z"
            }
          ]
        }
      ]
    },
    {
      "number": 35,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ0MTIzNTcx",
      "title": "Rework architecture document",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/35",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Removes the interfaces that were previously used (put into HTTP API doc?)\r\n- Removes concrete key management framework in favour of general guidelines for key registry\r\n- Refer to server key pairs rather than configurations: mirrors changes in protocol doc.\r\n- Add public verifiability as a running mode\r\n- TODOs for sections not filled in yet.\r\n\r\ncc @chris-wood @dvorak42 : Probably some inconsistencies here, but this is what I currently have based on our prior conversations around key management advice. Let me know what you think.",
      "createdAt": "2020-07-03T16:04:58Z",
      "updatedAt": "2020-07-09T10:13:26Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "cd9585cb8deb06d02bcf61309bd65137e8e6922d",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/arch-changes",
      "headRefOid": "c14b3464fa17723dd23f24d7b994069518aedaf2",
      "closedAt": "2020-07-09T10:13:26Z",
      "mergedAt": "2020-07-09T10:13:26Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "6cb05042b71d2e96dda09684b5bd61a5dadeb2cf"
      },
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is probably ready for full reviews now, I've added some diagrams of the ecosystem and key management. They're pretty general so could maybe be a bit more specific.",
          "createdAt": "2020-07-07T13:07:41Z",
          "updatedAt": "2020-07-07T13:07:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNDUyMzcw",
          "commit": {
            "abbreviatedOid": "1b111a2"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "First pass complete. Huge diff, but this is looking great! I very much like the removal of code from the architecture document. Some more figures will certainly help spell out the details more clearly.",
          "createdAt": "2020-07-06T22:44:31Z",
          "updatedAt": "2020-07-06T23:06:39Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "\u2764\ufe0f ",
              "createdAt": "2020-07-06T22:44:31Z",
              "updatedAt": "2020-07-08T10:02:41Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n- How clients should evaluate Issuer trust relationships.\r\n- Security and privacy properties of the protocol.\r\n```",
              "createdAt": "2020-07-06T22:46:03Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 172,
              "body": "I suspect this would contain, at a minimum, two clients and two issuers? What did you have in mind?",
              "createdAt": "2020-07-06T22:46:45Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 219,
              "body": "We haven't defined \"monitored\" yet, right? Should we define or or use a different word?",
              "createdAt": "2020-07-06T22:47:26Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 228,
              "body": "```suggestion\r\nto the protocol specification may allow public verification of tokens by \r\nentities which do not hold the secret Privacy Pass keying material. We highlight possible Client and\r\n```",
              "createdAt": "2020-07-06T22:49:51Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 231,
              "body": "How do we enforce this availability requirement? Would it be better to simply say that servers have some unique identifier? (Also, how do we define \"globally\"?)",
              "createdAt": "2020-07-06T22:52:07Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 819,
              "body": "```suggestion\r\nthat need to be satisfied for a key management system in a Privacy Pass ecosystem.\r\n```",
              "createdAt": "2020-07-06T22:52:51Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 827,
              "body": "```suggestion\r\na registry and how it operates will be covered elsewhere.\r\n```",
              "createdAt": "2020-07-06T22:53:15Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 825,
              "body": "```suggestion\r\noperating a public key registry in this document. Actual specification of such\r\n```",
              "createdAt": "2020-07-06T22:53:25Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 838,
              "body": "We seem to flip flop between Server and Issuer. Should we pick one and be consistent with it?",
              "createdAt": "2020-07-06T22:53:46Z",
              "updatedAt": "2020-07-08T10:02:41Z"
            },
            {
              "originalPosition": 850,
              "body": "```suggestion\r\nIn particular, Server key material MUST be publicly available in a tamper-proof\r\ndata structure, which we refer to as a key registry. A registry must be globally \r\nconsistent. Clients using the same registry should coordinate in some way to \r\nensure they have a  consistent view of said registry. This can be done via gossiping\r\nor some other mechanism. The exact mechanism for this coordination will be described\r\nelsewhere. It is assumed there will be at least one such mechanism.\r\n```\r\n\r\n",
              "createdAt": "2020-07-06T22:57:06Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 857,
              "body": "```suggestion\r\nIt is RECOMMENDED that each key registry is an append-only data structure, such as a Merkle Tree. \r\nThe key registry should be operated independently of any Issuer that publishes key material to the \r\nregistry. This ensures that any Client can make better judgements on whether to trust the registry \r\nand, transitively, each Server.\r\n```",
              "createdAt": "2020-07-06T22:58:14Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 908,
              "body": "```suggestion\r\nissuing tokens at any given time. Servers may use two or more keys for redemption\r\nto allow Servers for seamless key rotation.\r\n```",
              "createdAt": "2020-07-06T22:59:38Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 910,
              "body": "```suggestion\r\nKey rotations must be limited in frequency for similar reasons. See\r\n```",
              "createdAt": "2020-07-06T22:59:50Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 917,
              "body": "```suggestion\r\nthis implies that only a single ciphersuite is allowed per issuance period. If\r\n```",
              "createdAt": "2020-07-06T23:00:21Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 918,
              "body": "```suggestion\r\na Server wishes to change their ciphersuite, they MUST do so during a\r\n```",
              "createdAt": "2020-07-06T23:00:29Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 921,
              "body": "I think we can axe this section, as it's covered by the text above.",
              "createdAt": "2020-07-06T23:01:07Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 1017,
              "body": "nit:\r\n\r\n```suggestion\r\nactually processes issuance or redemption data. Finally, we also\r\n```",
              "createdAt": "2020-07-06T23:01:24Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 1049,
              "body": "nit: Proxied-Verifier, maybe?",
              "createdAt": "2020-07-06T23:02:28Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 1359,
              "body": "nit: bug in this sentence? \"that they only hold redemption tokens 4 Issuers\"",
              "createdAt": "2020-07-06T23:05:08Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            },
            {
              "originalPosition": 1558,
              "body": "```suggestion\r\n[[OPEN ISSUE: explain potential and mitigations for Issuer centralization]]\r\n```",
              "createdAt": "2020-07-06T23:05:38Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzcxMDI1",
          "commit": {
            "abbreviatedOid": "1b111a2"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T10:40:44Z",
          "updatedAt": "2020-07-07T10:40:44Z",
          "comments": [
            {
              "originalPosition": 838,
              "body": "Yeah I agree, I'm not sure what the best path here is though. Perhaps we should just go with Server everywhere?",
              "createdAt": "2020-07-07T10:40:44Z",
              "updatedAt": "2020-07-08T10:02:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzkwODA3",
          "commit": {
            "abbreviatedOid": "80881c5"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T11:12:26Z",
          "updatedAt": "2020-07-07T11:12:26Z",
          "comments": [
            {
              "originalPosition": 219,
              "body": "Changed to \"are publicly visible\"",
              "createdAt": "2020-07-07T11:12:26Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNzkzNDEz",
          "commit": {
            "abbreviatedOid": "80881c5"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T11:16:41Z",
          "updatedAt": "2020-07-07T11:16:41Z",
          "comments": [
            {
              "originalPosition": 1049,
              "body": "Small conflict with abbreviation of public verifier. Would \"Delegated-Verifier\" work?",
              "createdAt": "2020-07-07T11:16:41Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDgwNTY1",
          "commit": {
            "abbreviatedOid": "2d82fba"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T16:56:16Z",
          "updatedAt": "2020-07-07T16:56:16Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "```suggestion\r\nPrivacy Pass tokens from this Server. \r\n```",
              "createdAt": "2020-07-07T16:56:16Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDg3MzQx",
          "commit": {
            "abbreviatedOid": "2d82fba"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T17:04:38Z",
          "updatedAt": "2020-07-07T17:04:40Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "```suggestion\r\n~~~\r\n+--------------------------------------------------------+\r\n|                                                        |\r\n| Ecosystem                            +---+             |\r\n|                                      | C |             |\r\n|  +--------------+ <------ pkS1 ----> +---+             |\r\n|  |  Registry 1  |                                      |\r\n|  ++-------------+ <-------------- pkS1 --------> +---+ |\r\n|   |                                              | C | |\r\n|   |   +--------------+ <--------- pkS3 --------> +---+ |\r\n|   |   |  Registry 2  |                                 |\r\n|  pkS1 +----^-------^-+ <--------- pkS2 --------> +---+ |\r\n|   |        |       |                             | C | |\r\n|   |       pkS2    pkS3                           +---+ |\r\n|   |        |       |                                   |\r\n|  ++---+  +-+--+  +-+--+                                |\r\n|  | S1 |  | S2 |  | S3 |                                |\r\n|  +----+  +----+  +----+                                |\r\n|                                                        |\r\n+--------------------------------------------------------+\r\n~~~\r\n```",
              "createdAt": "2020-07-07T17:04:38Z",
              "updatedAt": "2020-07-08T10:01:53Z"
            }
          ]
        }
      ]
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ0ODg0ODU3",
      "title": "Protocol doc modifications after doing a full read-through",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/36",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-06T16:37:12Z",
      "updatedAt": "2020-07-09T10:19:52Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "6cb05042b71d2e96dda09684b5bd61a5dadeb2cf",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/protocol-mods",
      "headRefOid": "ed470e79bfe25f90b332ce337e48943549678060",
      "closedAt": "2020-07-09T10:19:52Z",
      "mergedAt": "2020-07-09T10:19:52Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "9a65207446f267ded879114d7e2750e2a79762d8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNDUxNzE3",
          "commit": {
            "abbreviatedOid": "d11fcf9"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "This is fine, though my suggestions in #33 will conflict if landed first.",
          "createdAt": "2020-07-06T22:42:42Z",
          "updatedAt": "2020-07-06T22:44:06Z",
          "comments": [
            {
              "originalPosition": 335,
              "body": "```suggestion\r\nServers SHOULD impose a hard ceiling on the number of\r\n```",
              "createdAt": "2020-07-06T22:42:42Z",
              "updatedAt": "2020-07-09T10:18:06Z"
            },
            {
              "originalPosition": 340,
              "body": "```suggestion\r\ntokens that can be issued in a single issuance phase to a Client. If\r\nthere is no limit, malicious clients could abuse this and cause excessive\r\ncomputation, leading to a Denial-of-Service attack.\r\n```",
              "createdAt": "2020-07-06T22:43:50Z",
              "updatedAt": "2020-07-09T10:18:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ1NDMzNjkx",
      "title": "Updates for HTTP API",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/37",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @dvorak42 for review. Mainly just removing the interfaces that were previously present and using the API functions from the protocol directly. I've also changed some of the wording around the key registry, and replaced client -> Client and server -> Server.\r\n\r\nLet me know if there is anything that you think I've missed.",
      "createdAt": "2020-07-07T14:00:33Z",
      "updatedAt": "2020-07-07T16:58:37Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "b0d666b8fac64a745763f811bfd92a16c5be4576",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/http-api-update",
      "headRefOid": "3f22f29ce4c245f3a962376767fc25d1bcb330b3",
      "closedAt": "2020-07-07T16:58:37Z",
      "mergedAt": "2020-07-07T16:58:37Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "00e18a842eefe9568419616010f85656744e9dcd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MDMwNzIy",
          "commit": {
            "abbreviatedOid": "3f22f29"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-07T15:56:36Z",
          "updatedAt": "2020-07-07T15:56:36Z",
          "comments": []
        }
      ]
    },
    {
      "number": 38,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3Mzk3Njc5",
      "title": "Common terminology across documents",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/38",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Issuer -> Server\r\n- Decapitalize (client/server)\r\n- Message -> Request\r\n\r\ncc @chris-wood, @dvorak42 \r\n\r\nI think we should be in okay shape to submit new drafts following these changes.",
      "createdAt": "2020-07-10T11:55:45Z",
      "updatedAt": "2020-07-10T14:59:52Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "9a65207446f267ded879114d7e2750e2a79762d8",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/consistent-wording",
      "headRefOid": "bb05056dd53f1e9884328af4ac8bb9478f4e81dc",
      "closedAt": "2020-07-10T14:59:52Z",
      "mergedAt": "2020-07-10T14:59:52Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "5fad78c77e02d6bbc848ed2154d8212f088dfb10"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NDU4Mjc0",
          "commit": {
            "abbreviatedOid": "bb05056"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-10T14:41:30Z",
          "updatedAt": "2020-07-10T14:41:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NDY5MDE1",
          "commit": {
            "abbreviatedOid": "bb05056"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-07-10T14:54:55Z",
          "updatedAt": "2020-07-10T14:54:55Z",
          "comments": []
        }
      ]
    },
    {
      "number": 41,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NTIxMzY1",
      "title": "Remove unnecessary key rotation section",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/41",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc @dvorak42 @chris-wood ",
      "createdAt": "2020-07-10T16:04:14Z",
      "updatedAt": "2020-07-10T16:44:56Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "5fad78c77e02d6bbc848ed2154d8212f088dfb10",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/small-edits",
      "headRefOid": "3d21868cd94f0930d242c17c0dfa60d6b75f4ad4",
      "closedAt": "2020-07-10T16:44:56Z",
      "mergedAt": "2020-07-10T16:44:56Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "a3e2e5307edebb819ce0509fe7608d82cb689df3"
      },
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "> LGTM, 1 week might still be too small of a window for actively malicious servers, but I think that ties in to the open issue regarding malicious servers rather than the generic key rotation considerations.\r\n\r\nYeah, I agree. Something to bring up for discussion.",
          "createdAt": "2020-07-10T16:44:48Z",
          "updatedAt": "2020-07-10T16:44:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NTI2NjAx",
          "commit": {
            "abbreviatedOid": "3d21868"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, 1 week might still be too small of a window for actively malicious servers, but I think that ties in to the open issue regarding malicious servers rather than the generic key rotation considerations.",
          "createdAt": "2020-07-10T16:12:51Z",
          "updatedAt": "2020-07-10T16:12:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 43,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ4MTU3NTM2",
      "title": "Small changes for release-01",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/43",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-13T10:15:06Z",
      "updatedAt": "2020-10-16T07:47:05Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "a3e2e5307edebb819ce0509fe7608d82cb689df3",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/release-01",
      "headRefOid": "72f462b1f5f6208cbdea616ff552345e1170339f",
      "closedAt": "2020-10-16T07:47:05Z",
      "mergedAt": "2020-10-16T07:47:05Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "ead20a2bbd26aaedf1b2d3c63b565d6935a952f5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ4Mzk1ODUx",
      "title": "Add Armando as a co-author",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/54",
      "state": "MERGED",
      "author": "armfazh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add Armando as a co-author",
      "createdAt": "2021-01-04T18:35:02Z",
      "updatedAt": "2021-01-05T10:19:30Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "ead20a2bbd26aaedf1b2d3c63b565d6935a952f5",
      "headRepository": "armfazh/base-drafts",
      "headRefName": "patch-1",
      "headRefOid": "bec65575999cc11d620f86bd0633fa7590c6e9fb",
      "closedAt": "2021-01-05T10:19:30Z",
      "mergedAt": "2021-01-05T10:19:30Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "8aed93d50e0e709302e1b4ace204996c46f88ef8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ4NTk0NzY5",
      "title": "Add Sof\u00eda Celi as author",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/55",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-01-05T02:37:04Z",
      "updatedAt": "2021-01-05T10:24:09Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "8aed93d50e0e709302e1b4ace204996c46f88ef8",
      "headRepository": "claucece/privacy-pass-ietf",
      "headRefName": "master",
      "headRefOid": "62eda1cb00110682e14c26e3d687c553f5c18b4b",
      "closedAt": "2021-01-05T10:23:02Z",
      "mergedAt": "2021-01-05T10:23:02Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "715ed91498a3aaa034fe5892d588a669b36d9c3c"
      },
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you @alxdavids !",
          "createdAt": "2021-01-05T10:24:08Z",
          "updatedAt": "2021-01-05T10:24:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNjcyNDI0",
          "commit": {
            "abbreviatedOid": "62eda1c"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Just resolved conflicts and alphabetised authors",
          "createdAt": "2021-01-05T10:22:56Z",
          "updatedAt": "2021-01-05T10:22:56Z",
          "comments": []
        }
      ]
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ4ODg1MTUw",
      "title": "Rename drafts for adoption into WG",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/56",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Also update CONTRIBUTING.md with correct links",
      "createdAt": "2021-01-05T10:41:03Z",
      "updatedAt": "2021-01-05T16:05:13Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "715ed91498a3aaa034fe5892d588a669b36d9c3c",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/rename-drafts",
      "headRefOid": "cfcfe45ef5df21bac0c0b8287939cecc9444b03f",
      "closedAt": "2021-01-05T16:05:13Z",
      "mergedAt": "2021-01-05T16:05:13Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "0f1ded4703f19a156b2fb35c37d6809152a38b6d"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxODI3MTI3",
          "commit": {
            "abbreviatedOid": "cfcfe45"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks reasonable. Once this lands we should see about hooking about the gh-pages generation and link to that.",
          "createdAt": "2021-01-05T14:22:49Z",
          "updatedAt": "2021-01-05T14:22:49Z",
          "comments": []
        }
      ]
    },
    {
      "number": 57,
      "id": "MDExOlB1bGxSZXF1ZXN0NTQ5MTY1NjQ1",
      "title": "Add github workflows",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/57",
      "state": "MERGED",
      "author": "dvorak42",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This should add it the id-template workflows to automatically generate GH pages.",
      "createdAt": "2021-01-05T15:21:13Z",
      "updatedAt": "2021-01-05T16:13:53Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "715ed91498a3aaa034fe5892d588a669b36d9c3c",
      "headRepository": "dvorak42/privacy-pass-ietf",
      "headRefName": "add-gh-workflows",
      "headRefOid": "969b22b3041727fc3f198ef9b912d2ed4b3ef699",
      "closedAt": "2021-01-05T16:13:53Z",
      "mergedAt": "2021-01-05T16:13:52Z",
      "mergedBy": "bemasc",
      "mergeCommit": {
        "oid": "6b3e974cbce8c18ffac1bee7aae1afa5704b48f8"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxOTI1Nzc2",
          "commit": {
            "abbreviatedOid": "969b22b"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-01-05T16:13:40Z",
          "updatedAt": "2021-01-05T16:13:40Z",
          "comments": []
        }
      ]
    },
    {
      "number": 58,
      "id": "MDExOlB1bGxSZXF1ZXN0NTU2OTQ0NTIz",
      "title": "Align with voprf draft",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/58",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc. @chris-wood @alxdavids ",
      "createdAt": "2021-01-18T17:14:31Z",
      "updatedAt": "2021-02-17T09:24:58Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "ed5cd0df54a9204f8dc5b91f4fdbc234e2afe8e9",
      "headRepository": "claucece/privacy-pass-ietf",
      "headRefName": "master",
      "headRefOid": "82275a679dae9d08d92b28c67ee4a3c7dd31dde1",
      "closedAt": "2021-02-17T09:24:58Z",
      "mergedAt": "2021-02-17T09:24:58Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "0ff3a561f748cd722bc7ad128fe947264257df68"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcxMDUxNzUy",
          "commit": {
            "abbreviatedOid": "82275a6"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-01-19T09:28:10Z",
          "updatedAt": "2021-01-19T09:28:10Z",
          "comments": []
        }
      ]
    },
    {
      "number": 59,
      "id": "MDExOlB1bGxSZXF1ZXN0NTczODc4Njg1",
      "title": "Fix some issues with the notation",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/59",
      "state": "MERGED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "cc./ @alxdavids @armfazh @chris-wood ",
      "createdAt": "2021-02-16T02:03:47Z",
      "updatedAt": "2021-02-17T09:25:39Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "ed5cd0df54a9204f8dc5b91f4fdbc234e2afe8e9",
      "headRepository": "claucece/privacy-pass-ietf",
      "headRefName": "notation-fix",
      "headRefOid": "78d21082eb394c487d2011d976f6e2f87e5f3af0",
      "closedAt": "2021-02-17T09:25:39Z",
      "mergedAt": "2021-02-17T09:25:39Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "396c5683a1cab974111ced49dae6119e8d47031f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwOTA5NzE1",
          "commit": {
            "abbreviatedOid": "78d2108"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-16T06:14:01Z",
          "updatedAt": "2021-02-16T06:14:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxOTg4NTU2",
          "commit": {
            "abbreviatedOid": "78d2108"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-17T09:25:32Z",
          "updatedAt": "2021-02-17T09:25:32Z",
          "comments": []
        }
      ]
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc1ODUzNzQ0",
      "title": "Add metadata discussion.",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/60",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #51, to some extent.\r\n\r\ncc @alxdavids ",
      "createdAt": "2021-02-18T17:20:43Z",
      "updatedAt": "2021-02-18T17:56:04Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "396c5683a1cab974111ced49dae6119e8d47031f",
      "headRepository": "chris-wood/privacy-pass-ietf",
      "headRefName": "caw/metadata-fix",
      "headRefOid": "c64510fbdf82e60172b55ab2b5e59d88ee700a58",
      "closedAt": "2021-02-18T17:56:04Z",
      "mergedAt": "2021-02-18T17:56:04Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "00bbf4dae86611c96ef1ca9dfec2de602102fd8b"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@alxdavids updated with citations. I'll take #49, #48, and #47 next. (Trying to get these done before the upcoming deadline.)",
          "createdAt": "2021-02-18T17:51:30Z",
          "updatedAt": "2021-02-18T17:51:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNDY5NTk0",
          "commit": {
            "abbreviatedOid": "788366e"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks Chris, this looks great (and thanks for joining me! :D). I have a few comments to address. Also, I hadn't considered the differences between opaque and transparent public metadata, but there is an important distinction there so thanks for bringing it up.",
          "createdAt": "2021-02-18T17:27:07Z",
          "updatedAt": "2021-02-18T17:32:27Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "We probably need to update the refs to use the new WG versions.\r\n```suggestion\r\nissuance flow. In {{draft-ietf-privacypass-protocol}}, it is possible to include\r\n```",
              "createdAt": "2021-02-18T17:27:07Z",
              "updatedAt": "2021-02-18T17:49:22Z"
            },
            {
              "originalPosition": 58,
              "body": "It might be worth separating the last two paragraphs as they relate mostly to privacy considerations. What do you think?\r\n\r\n```suggestion\r\n\r\n## Client privacy implications\r\n\r\n```",
              "createdAt": "2021-02-18T17:28:57Z",
              "updatedAt": "2021-02-18T17:49:22Z"
            },
            {
              "originalPosition": 50,
              "body": "We may want to provide references to constructions that permit such metadata to be added (links to KLOS20 and the FB paper). However, it might just be better to wait for the CFRG drafts?",
              "createdAt": "2021-02-18T17:30:48Z",
              "updatedAt": "2021-02-18T17:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNDgxOTIz",
          "commit": {
            "abbreviatedOid": "fb97f57"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T17:40:02Z",
          "updatedAt": "2021-02-18T17:40:02Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Yeah, good call :-) ",
              "createdAt": "2021-02-18T17:40:02Z",
              "updatedAt": "2021-02-18T17:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNDgyMjE3",
          "commit": {
            "abbreviatedOid": "d08a120"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T17:40:23Z",
          "updatedAt": "2021-02-18T17:40:24Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Nah, citing them here is a good idea. Let me add them!",
              "createdAt": "2021-02-18T17:40:23Z",
              "updatedAt": "2021-02-18T17:49:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNDkwMzA2",
          "commit": {
            "abbreviatedOid": "c64510f"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T17:49:23Z",
          "updatedAt": "2021-02-18T17:49:24Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Done!",
              "createdAt": "2021-02-18T17:49:23Z",
              "updatedAt": "2021-02-18T17:49:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNDk2MTQw",
          "commit": {
            "abbreviatedOid": "c64510f"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM! I'll take some of the other issues.",
          "createdAt": "2021-02-18T17:55:54Z",
          "updatedAt": "2021-02-18T17:55:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc1OTA1MDY1",
      "title": "Add token expiration discussion.",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/61",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Replace suggested registry with list of other options. The rationale is that a registry may be sufficient but not necessary. There are other options that might work. \r\n\r\nI suggest we work with @chelseakomlo on a draft describing these techniques in more detail.\r\n\r\ncc @alxdavids \r\n\r\nCloses #49.",
      "createdAt": "2021-02-18T18:45:56Z",
      "updatedAt": "2021-02-19T14:47:18Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "00bbf4dae86611c96ef1ca9dfec2de602102fd8b",
      "headRepository": "chris-wood/privacy-pass-ietf",
      "headRefName": "caw/add-token-expiration",
      "headRefOid": "c28e39773a1b893162b4aa8eedb425627694badc",
      "closedAt": "2021-02-19T14:47:18Z",
      "mergedAt": "2021-02-19T14:47:18Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "9a5e8aaffd0cdf1c65d79135fa6ba822ff6b27dd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0MjU2ODQy",
          "commit": {
            "abbreviatedOid": "c28e397"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This LGTM. Agreed that working on a document that tackles these questions specifically would be worthwhile.",
          "createdAt": "2021-02-19T14:47:11Z",
          "updatedAt": "2021-02-19T14:47:11Z",
          "comments": []
        }
      ]
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2NjIxODYx",
      "title": "First attempt at solving #50.",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/62",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add an extra round to the issuance phase\r\n- Specify whether commitments are required in ciphersuites\r\n- Allow possibility for null state values\r\n\r\ncc @claucece, @chris-wood, @dvorak42, @armfazh for review.   ",
      "createdAt": "2021-02-19T17:58:23Z",
      "updatedAt": "2021-02-22T08:33:13Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "9a5e8aaffd0cdf1c65d79135fa6ba822ff6b27dd",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/50",
      "headRefOid": "5c749d6f7360d21595e75520e8883b2d095c7de7",
      "closedAt": "2021-02-22T08:33:13Z",
      "mergedAt": "2021-02-22T08:33:13Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "cdb894f95d7c3d3f4bf0e6a365be222d97763586"
      },
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @chris-wood, changes all look good. What do you think about the `GenerateState` algorithm? Maybe I can just add some text that leaves this up to the implementer?",
          "createdAt": "2021-02-20T13:10:40Z",
          "updatedAt": "2021-02-20T13:10:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's probably only a function that 3/4-message protocols need to implement, right? I wouldn't expect the VOPRF draft to implement it, since COMMIT=false for those suites.\n\nAlso, what do you think about renaming it to GenerateCommitment?",
          "createdAt": "2021-02-20T13:48:42Z",
          "updatedAt": "2021-02-20T13:48:42Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "> That's probably only a function that 3/4-message protocols need to implement, right? I wouldn't expect the VOPRF draft to implement it, since COMMIT=false for those suites.\r\n> \r\n> Also, what do you think about renaming it to GenerateCommitment?\r\n\r\nSounds good, I've also replaced `state` with `commitment` throughout to avoid mishaps. ",
          "createdAt": "2021-02-20T14:40:22Z",
          "updatedAt": "2021-02-20T14:40:22Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like this ;) Thank you @alxdavids ! But, should the `CommitRequest` and `GenerateCommitment` should be added to the `API functions` sections, as `Generate` and others?",
          "createdAt": "2021-02-21T01:32:40Z",
          "updatedAt": "2021-02-21T13:21:05Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> \r\n> I like this ;) Thank you @alxdavids ! But, should the `CommitRequest and `GenerateCommitment`should be added to the`API functions`sections, as`Generate` and others?\r\n\r\nYeah I think you're right. I didn't add them as I wasn't exactly sure how they should be implemented, but I guess that we can leave that for the underlying ciphersuites to decide.",
          "createdAt": "2021-02-21T09:11:30Z",
          "updatedAt": "2021-02-21T09:11:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, maybe just leave an OPEN ISSUE noting that they should be defined? If you want something, maybe this would work? (I replaced server_id with metadata, though I wonder if client-provided metadata is best supplied during the commit flow or the issuance flow?) \r\n\r\n```\r\nPrepare\r\n\r\nA function run by the client to prepare for a commitment will used during the issuance flow of the Privacy Pass protocol.\r\n\r\nInputs:\r\n\r\ninfo: An opaque byte application-specific byte string.\r\n\r\nNone\r\n\r\nOutputs:\r\n\r\ncommit_req: A CommitRequest struct.\r\n\r\n\r\n\r\nCommit\r\n\r\nA function run by the server to commit to a Privacy Pass issuance flow.\r\n\r\nInputs:\r\n\r\npkS: A server PublicKey.\r\nskS: A server PrivateKey.\r\ncommit_req: A CommitRequest struct.\r\n\r\nOutputs:\r\n\r\ncommit_resp: A CommitResponse struct.\r\n```",
          "createdAt": "2021-02-21T14:57:37Z",
          "updatedAt": "2021-02-21T14:57:37Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood Thanks for the example, I've altered the PR to include this and @claucece's feedback.",
          "createdAt": "2021-02-21T16:01:38Z",
          "updatedAt": "2021-02-21T16:01:38Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good! Shall we merge and the submit this and -architecture?\r\n",
          "createdAt": "2021-02-21T16:38:53Z",
          "updatedAt": "2021-02-21T16:38:53Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "> \r\n> \r\n> Looks good! Shall we merge and the submit this and -architecture?\r\n\r\nSGTM! I'm AFK for the rest of today, but I'll handle it tomorrow if that's okay with everyone else?",
          "createdAt": "2021-02-21T16:41:25Z",
          "updatedAt": "2021-02-21T16:41:25Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@alxdavids thank you! looking good ;)",
          "createdAt": "2021-02-21T20:41:17Z",
          "updatedAt": "2021-02-21T20:41:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NDQ0Njgy",
          "commit": {
            "abbreviatedOid": "162d6a0"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "This looks good! I think we can shift the presentation of the `st` value to be something about a reference to some state, rather than actual state itself. That allows the server to use it as a reference (a key in some database) or as state (encrypted cookie). ",
          "createdAt": "2021-02-19T18:17:35Z",
          "updatedAt": "2021-02-19T18:25:36Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "```suggestion\r\ncertain ciphersuites that require client and servers commit to some state. When such\r\n```",
              "createdAt": "2021-02-19T18:17:35Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\n`st` with the `IssuanceRequest` message. The server MUST check that the\r\n```",
              "createdAt": "2021-02-19T18:17:51Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 44,
              "body": "```suggestion\r\nstate corresponds to `st` that was previously committed. This\r\n```",
              "createdAt": "2021-02-19T18:18:51Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 48,
              "body": "```suggestion\r\nrequires the commitment to either be a reference to some state on the server, \r\nor the commitment be an encrypted (and authenticated) blob that the server can\r\nuse to recover state. The mechanism by which servers handle this state is implementation\r\nspecific, and similar to how TLS session resumption state is managed; see {{RFC8446}}\r\nfor details.\r\n```",
              "createdAt": "2021-02-19T18:21:28Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 54,
              "body": "```suggestion\r\ncInput = Generate(m, \"\")\r\n```",
              "createdAt": "2021-02-19T18:21:51Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 57,
              "body": "```suggestion\r\nA server that is expecting some non-empty `st` to be passed must abort\r\n```",
              "createdAt": "2021-02-19T18:22:02Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 58,
              "body": "```suggestion\r\nthe protocol on receiving a request containing an empty `st` value.\r\n```",
              "createdAt": "2021-02-19T18:22:10Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nempty state messages.\r\n```",
              "createdAt": "2021-02-19T18:22:22Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\ncorrespond to some state that the server has generated. The structure\r\nand format of this value is implementation specific depending on whether\r\nthe server is stateful.\r\n```",
              "createdAt": "2021-02-19T18:23:12Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 123,
              "body": "```suggestion\r\nphase of the protocol is necessary. When this is false, the client\r\n```",
              "createdAt": "2021-02-19T18:23:40Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 125,
              "body": "```suggestion\r\nignores the first message and uses an empty value for the state parameter\r\nto `Generate`.\r\n```",
              "createdAt": "2021-02-19T18:24:14Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            },
            {
              "originalPosition": 77,
              "body": "Interesting -- do we need this? Can it be empty?",
              "createdAt": "2021-02-19T18:24:42Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NzUwOTY0",
          "commit": {
            "abbreviatedOid": "63d6bf4"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-20T13:09:31Z",
          "updatedAt": "2021-02-20T13:09:32Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I was allowing for the possibility that the client may only want to allow commitments for certain types (e.g. it may only want to allow server S with ciphersuite `c1`, rather than `c2`). The `server_id` was kind of a placeholder for that. However, it is pretty ugly right now, so I would be happy to remove it.",
              "createdAt": "2021-02-20T13:09:31Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NzYwNzMw",
          "commit": {
            "abbreviatedOid": "90f28bd"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-20T15:20:48Z",
          "updatedAt": "2021-02-20T15:20:49Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "\ud83d\udc4d Eh, it's probably fine for now.",
              "createdAt": "2021-02-20T15:20:48Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0Nzk4NTQw",
          "commit": {
            "abbreviatedOid": "90f28bd"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-21T01:31:52Z",
          "updatedAt": "2021-02-21T01:31:53Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "When the commitment does not correspond to `com` that was previously\r\ncommitted, should this define a specific error that we need to add to the `Error types`? ",
              "createdAt": "2021-02-21T01:31:52Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0ODIxMzUy",
          "commit": {
            "abbreviatedOid": "90f28bd"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-21T09:10:35Z",
          "updatedAt": "2021-02-21T09:10:35Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "@claucece Good point! Yes it should be.",
              "createdAt": "2021-02-21T09:10:35Z",
              "updatedAt": "2021-02-21T16:24:11Z"
            }
          ]
        }
      ]
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3NDUxMjI5",
      "title": "Fix minor typos before -01 release",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/64",
      "state": "MERGED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-22T08:40:00Z",
      "updatedAt": "2021-03-05T09:33:44Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "cdb894f95d7c3d3f4bf0e6a365be222d97763586",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/minor-change",
      "headRefOid": "c722abf664f78f9646d0bf0e0549c1c56e771aa5",
      "closedAt": "2021-03-05T09:33:44Z",
      "mergedAt": "2021-03-05T09:33:44Z",
      "mergedBy": "alxdavids",
      "mergeCommit": {
        "oid": "cde660567c79230d4ac514e2567445ae478b63e2"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1NDI2OTg0",
          "commit": {
            "abbreviatedOid": "c807fb9"
          },
          "author": "chris-wood",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM modulo the -latest change.",
          "createdAt": "2021-02-22T14:50:21Z",
          "updatedAt": "2021-02-22T14:50:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "This typically stays `latest` -- are you trying to build `-01`? If so, let's chat offline and I can help you figure it out!",
              "createdAt": "2021-02-22T14:50:21Z",
              "updatedAt": "2021-02-22T15:18:17Z"
            }
          ]
        }
      ]
    },
    {
      "number": 75,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg2MTgxOTY2",
      "title": "Add redemption context discussion to architecture and HTTP API.",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/75",
      "state": "MERGED",
      "author": "dvorak42",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Initial work for fixing #66 .",
      "createdAt": "2021-07-08T16:58:43Z",
      "updatedAt": "2021-07-09T15:00:28Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "cde660567c79230d4ac514e2567445ae478b63e2",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "redemption_context",
      "headRefOid": "96c4a340785c0af85acfb184ed260e7a4a3fd073",
      "closedAt": "2021-07-09T15:00:28Z",
      "mergedAt": "2021-07-09T15:00:28Z",
      "mergedBy": "dvorak42",
      "mergeCommit": {
        "oid": "644b2fe6855286cf90c7b54795f5045e1bfb952c"
      },
      "comments": [
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood ",
          "createdAt": "2021-07-08T16:59:43Z",
          "updatedAt": "2021-07-08T16:59:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzAyODAwNTM0",
          "commit": {
            "abbreviatedOid": "c58929d"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks @dvorak42! This looks good, I have mostly just a few nits to resolve. ",
          "createdAt": "2021-07-09T08:18:23Z",
          "updatedAt": "2021-07-09T08:24:15Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\nwhile preventing the joining of a number of different tokens is for the\r\n```",
              "createdAt": "2021-07-09T08:18:23Z",
              "updatedAt": "2021-07-09T08:24:06Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nclient to maintain sharded \"redemption contexts\". This would allow the\r\n```",
              "createdAt": "2021-07-09T08:18:57Z",
              "updatedAt": "2021-07-09T08:24:06Z"
            },
            {
              "originalPosition": 43,
              "body": "To keep consistent with the other boolean checks\r\n```suggestion\r\n                               if resp.success {\r\n```",
              "createdAt": "2021-07-09T08:20:17Z",
              "updatedAt": "2021-07-09T08:24:06Z"
            },
            {
              "originalPosition": 62,
              "body": "Should we link back to the architecture doc here as well, just to reinforce the connection.\r\n```suggestion\r\nstorage. Generally this is the top-level origin. Any redemption context should be built following the principles outlined in {{draft-ietf-privacypass-architecture}} and later in {{privacy}}.\r\n```",
              "createdAt": "2021-07-09T08:21:34Z",
              "updatedAt": "2021-07-09T08:24:06Z"
            },
            {
              "originalPosition": 20,
              "body": "```suggestion\r\nagainst. An empty redemption is returned when the limit has been\r\n```",
              "createdAt": "2021-07-09T08:23:18Z",
              "updatedAt": "2021-07-09T08:24:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg2ODEyNjgw",
      "title": "Awkward binding to blind RSA.",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/76",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This at least tries to show that such a mapping is possible. It's very far from perfect. There are a lot of rough edges in the protocol shape. I'll file separate issues to clean them up.\r\n\r\nOpening as a draft purely for _demonstration purposes_.",
      "createdAt": "2021-07-09T14:00:42Z",
      "updatedAt": "2021-10-29T17:08:56Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "cde660567c79230d4ac514e2567445ae478b63e2",
      "headRepository": "chris-wood/privacy-pass-ietf",
      "headRefName": "caw/draft-rsa-binding",
      "headRefOid": "b8c13dd7ba14700afc128266a9df4b79e3766b28",
      "closedAt": "2021-10-29T17:08:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 78,
      "id": "MDExOlB1bGxSZXF1ZXN0Njg2ODI2NTQx",
      "title": "Add metadata considerations #63",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/78",
      "state": "CLOSED",
      "author": "claucece",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-07-09T14:19:34Z",
      "updatedAt": "2022-01-31T20:32:52Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "cde660567c79230d4ac514e2567445ae478b63e2",
      "headRepository": "claucece/privacy-pass-ietf",
      "headRefName": "master",
      "headRefOid": "8bc153a0e592dd71de5f551e31081a535df19126",
      "closedAt": "2022-01-31T20:32:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "cc.: @alxdavids @chris-wood @dvorak42 @armfazh ",
          "createdAt": "2021-07-23T14:25:16Z",
          "updatedAt": "2021-07-27T20:23:06Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as overcome by events.",
          "createdAt": "2022-01-31T20:32:52Z",
          "updatedAt": "2022-01-31T20:32:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE1MDY0MDU3",
          "commit": {
            "abbreviatedOid": "8999628"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This looks to be in the right direction! I have some suggestions that aim to fix some editorial issues, reduce text, and simplify notation. We should note also that this assumes the VOPRF document will be extended to support metadata.",
          "createdAt": "2021-07-26T16:41:21Z",
          "updatedAt": "2021-07-26T16:56:20Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'd recommend removing this entire section and folding it into the second paragraph above. Specifically, I might note that a timestamp-based epoch or the client's ASN could be used as transparent public metadata. ",
              "createdAt": "2021-07-26T16:41:21Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 46,
              "body": "This is a useful paragraph to keep. Perhaps by appending it to the last paragraph in the section above?",
              "createdAt": "2021-07-26T16:41:56Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-07-26T16:44:05Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 47,
              "body": "Let's spell out these parameters? That is, `cMetadata` => `clientMetadata`.",
              "createdAt": "2021-07-26T16:45:17Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nis consistent across the entire ecosystem.\r\n```",
              "createdAt": "2021-07-26T16:45:33Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 47,
              "body": "Also, shouldn't both parties have client and server metadata as input?",
              "createdAt": "2021-07-26T16:47:14Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\nby the server or client.\r\n```",
              "createdAt": "2021-07-26T16:47:27Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 135,
              "body": "This means that metadata is length-prefixed, which isn't the case as described in text above. Maybe we just say that it's an arbitrary-length byte string and leave it at that? Then we could delete this section entirely. (See the proposed suggestions below!)",
              "createdAt": "2021-07-26T16:47:59Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 146,
              "body": "```suggestion\r\n- `sMetadata`: A optional server metadata, an arbitrary-length byte string.\r\n- `cMetadata`: A optional client metadata, an arbitrary-length byte string.\r\n```",
              "createdAt": "2021-07-26T16:48:44Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 155,
              "body": "```suggestion\r\n- `sMetadata`: A optional server metadata, an arbitrary-length byte string.\r\n- `cMetadata`: A optional client metadata, an arbitrary-length byte string.\r\n```",
              "createdAt": "2021-07-26T16:48:57Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\n- `sMetadata`: A optional server metadata, an arbitrary-length byte string.\r\n- `cMetadata`: A optional client metadata, an arbitrary-length byte string.\r\n```",
              "createdAt": "2021-07-26T16:49:05Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 173,
              "body": "```suggestion\r\n- `sMetadata`: A optional server metadata, an arbitrary-length byte string.\r\n- `cMetadata`: A optional client metadata, an arbitrary-length byte string.\r\n```",
              "createdAt": "2021-07-26T16:49:14Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nThe client and server also agree on public metadata values used during the protocol.\r\nSee {{client-setup}} for more information about this metadata. This configuration must be available to all\r\n```",
              "createdAt": "2021-07-26T16:52:44Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nAs above, the client and server also agree on public metadata values used during the protocol.\r\nEach metadata value is an arbitrary-length byte string. The client picks an integer value `m > 0` of tokens to\r\n```",
              "createdAt": "2021-07-26T16:53:47Z",
              "updatedAt": "2021-07-26T16:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE1Mzk4ODc3",
          "commit": {
            "abbreviatedOid": "c6df4ee"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T01:10:40Z",
          "updatedAt": "2021-07-27T01:10:40Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "Yeah.. I didn't know how to make it as long as wanted in the TLS language. Changed now ;)",
              "createdAt": "2021-07-27T01:10:40Z",
              "updatedAt": "2021-07-27T01:10:40Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE1Mzk4OTYy",
          "commit": {
            "abbreviatedOid": "8999628"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T01:10:51Z",
          "updatedAt": "2021-07-27T01:10:51Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Changed ;)",
              "createdAt": "2021-07-27T01:10:51Z",
              "updatedAt": "2021-07-27T01:10:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE1Mzk5MTk3",
          "commit": {
            "abbreviatedOid": "c6df4ee"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T01:11:29Z",
          "updatedAt": "2021-07-27T01:11:30Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Changed.",
              "createdAt": "2021-07-27T01:11:30Z",
              "updatedAt": "2021-07-27T01:11:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE1Mzk5MzAx",
          "commit": {
            "abbreviatedOid": "c6df4ee"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T01:11:46Z",
          "updatedAt": "2021-07-27T01:11:47Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done ;)",
              "createdAt": "2021-07-27T01:11:47Z",
              "updatedAt": "2021-07-27T01:11:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE1Mzk5Mzcy",
          "commit": {
            "abbreviatedOid": "c6df4ee"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T01:11:59Z",
          "updatedAt": "2021-07-27T01:11:59Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Yes! changed everywhere.",
              "createdAt": "2021-07-27T01:11:59Z",
              "updatedAt": "2021-07-27T01:11:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzE1Mzk5NDM0",
          "commit": {
            "abbreviatedOid": "c6df4ee"
          },
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-27T01:12:10Z",
          "updatedAt": "2021-07-27T01:12:10Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Done.",
              "createdAt": "2021-07-27T01:12:10Z",
              "updatedAt": "2021-07-27T01:12:10Z"
            }
          ]
        }
      ]
    },
    {
      "number": 79,
      "id": "MDExOlB1bGxSZXF1ZXN0NjkxNTQ2MzQw",
      "title": "Refactor to focus on protocol messages and interactions.",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/79",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Starting as a draft to demonstrate what I had in mind for #77.\r\n\r\nThis removes a lot of text, shifting the focus away from client and server implementation-specific APIs towards the protocol messages exchanged during issuance and redemption, and their encoding. This does seem to simplify a lot, as it encapsulates all of the special features of different underlying cryptographic protocols (public verifiability, metadata, etc) to those protocols. The result is just a thin wrapper around these schemes with logic specific to and necessary for privacy pass, i.e., generating nonces as token inputs, publishing server configurations, and so on.\r\n\r\nIt's not complete, but I wanted to throw it up early to get some preliminary feedback. ",
      "createdAt": "2021-07-16T14:46:31Z",
      "updatedAt": "2021-10-29T17:09:03Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "920b6e608e2774837ae23487a4d772d6f7a2b5e3",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/protocol-message-focus",
      "headRefOid": "185a72131888bb35265137680bf2ae6df7d9c93c",
      "closedAt": "2021-10-29T17:09:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5NjE4MDU0",
          "commit": {
            "abbreviatedOid": "185a721"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-19T14:28:50Z",
          "updatedAt": "2021-07-19T14:55:30Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Any chance we can add the p384_sha512 variant?",
              "createdAt": "2021-07-19T14:28:51Z",
              "updatedAt": "2021-07-19T14:55:30Z"
            },
            {
              "originalPosition": 503,
              "body": "Might be an issue with the current standard, but shouldn't the server have the ability to sign/evaluate fewer than the number of blinded_elements sent by the client?\r\n\r\n(and then we'll need a uint8 or length prefix in the IssuanceResponse for the client to be able to parse).",
              "createdAt": "2021-07-19T14:37:19Z",
              "updatedAt": "2021-07-19T14:55:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5NjY2NzAw",
          "commit": {
            "abbreviatedOid": "185a721"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-19T15:09:00Z",
          "updatedAt": "2021-07-19T15:09:00Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Yeah, I was just getting one down to start.",
              "createdAt": "2021-07-19T15:09:00Z",
              "updatedAt": "2021-07-19T15:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzA5NjY5MDI0",
          "commit": {
            "abbreviatedOid": "185a721"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-07-19T15:10:58Z",
          "updatedAt": "2021-07-19T15:10:58Z",
          "comments": [
            {
              "originalPosition": 503,
              "body": "Yeah, good point. We should probably length prefix each of the element lists in request and response to make this easier to address later on.",
              "createdAt": "2021-07-19T15:10:58Z",
              "updatedAt": "2021-07-19T15:10:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 83,
      "id": "PR_kwDODeTEy84scsTn",
      "title": "Initial attempt at integration doc",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/83",
      "state": "CLOSED",
      "author": "alxdavids",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is my first draft of an integration document for replacing the current protocol doc. I've tried to keep it as concise as possible. A few questions:\r\n\r\n- Would it be better to be more specific about how the POPRF algorithms are used? Or is this level of detail sufficient?\r\n- Can we leave considerations about how public keys are distributed and consumed to the HTTP API doc?\r\n- Is it reasonable to leave metadata-level considerations to the architecture doc.\r\n\r\nLet me know what you think so far, cc @chris-wood, @bemasc, @dvorak42, @jsalowey, @claucece, @armfazh ",
      "createdAt": "2021-09-29T13:00:43Z",
      "updatedAt": "2022-01-31T20:32:41Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "920b6e608e2774837ae23487a4d772d6f7a2b5e3",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "alxdavids/integration-doc",
      "headRefOid": "eb5c07d7519af27d37b535a035a85f2dee1c0cb5",
      "closedAt": "2022-01-31T20:32:41Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think this doc might be the right place to declare an IANA registry of Privacy Pass ciphersuites, and explain how entries in that registry map to the VOPRF draft, and are represented in the HTTP API.",
          "createdAt": "2021-09-29T13:47:59Z",
          "updatedAt": "2021-09-29T13:47:59Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@alxdavids, can you please review and respond to the comments above?",
          "createdAt": "2021-10-01T14:43:40Z",
          "updatedAt": "2021-10-01T14:43:40Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @chris-wood @dvorak42 @bemasc for the review and suggestions. I've updated the draft with your changes (@chris-wood and @dvorak42 I've also added you as authors due to contributing concrete text). What do you think?\r\n\r\n@bemasc: Is the IANA considerations section that I've added sufficient? ",
          "createdAt": "2021-10-01T16:36:49Z",
          "updatedAt": "2021-10-01T16:36:49Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thanks @chris-wood @dvorak42 @bemasc for the review and suggestions. I've updated the draft with your changes (@chris-wood and @dvorak42 I've also added you as authors due to contributing concrete text). What do you think?\r\n\r\nThe new text looks mostly good to me, modulo a couple more suggestions and a question about the ciphersuites. @alxdavids, why do we need PP suites when we have POPRF suites?",
          "createdAt": "2021-10-05T12:07:17Z",
          "updatedAt": "2021-10-05T12:07:17Z"
        },
        {
          "author": "claucece",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It looks good @alxdavids !\r\n\r\n> Would it be better to be more specific about how the POPRF algorithms are used? Or is this level of detail sufficient?\r\n\r\nI think this level is sufficient ;)",
          "createdAt": "2021-10-05T13:00:57Z",
          "updatedAt": "2021-10-05T13:00:57Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "Removed the IANA registry for now following conversation with @chris-wood, @dvorak42, @claucece. Also locked the OPRF ciphersuite to P384. We can figure out how to define the appropriate IANA registries in the future. ",
          "createdAt": "2021-10-19T12:43:08Z",
          "updatedAt": "2021-10-19T12:43:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "This is missing IANA (empty) and security (ideally non-empty) considerations, as well as acknowledgements (though that's not necessary). Can we add those?",
          "createdAt": "2021-10-29T17:10:00Z",
          "updatedAt": "2021-10-29T17:10:12Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "@chris-wood I added the missing sections, is there anything else that needs addressing?",
          "createdAt": "2021-12-09T09:19:50Z",
          "updatedAt": "2021-12-09T09:19:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, @alxdavids. It's good for now. We may need to update the issuance and redemption details to use the new HTTP-based authentication challenge being worked on in parallel, but the core of the issuance flow will remain the same. ",
          "createdAt": "2021-12-09T13:34:54Z",
          "updatedAt": "2021-12-09T13:34:54Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "> Thanks, @alxdavids. It's good for now. We may need to update the issuance and redemption details to use the new HTTP-based authentication challenge being worked on in parallel, but the core of the issuance flow will remain the same.\r\n\r\nSounds good, shall I merge this for now?",
          "createdAt": "2021-12-13T09:45:40Z",
          "updatedAt": "2021-12-13T09:45:40Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think we can merge this as-is. This being a new document would need to go through the adoption process (@bemasc can say more). Alternatively, we just replace the existing -protocol document with the contents in this PR.",
          "createdAt": "2021-12-13T12:56:13Z",
          "updatedAt": "2021-12-13T12:57:07Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "I did this alignment in #87. @alxdavids, please have a look!",
          "createdAt": "2021-12-14T00:18:50Z",
          "updatedAt": "2021-12-14T00:18:50Z"
        },
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "> I did this alignment in #87. @alxdavids, please have a look!\r\n\r\nSounds good, I will take a look at this tomorrow morning my time \ud83d\udc4d ",
          "createdAt": "2021-12-14T18:05:30Z",
          "updatedAt": "2021-12-14T18:05:30Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing as overcome by events.",
          "createdAt": "2022-01-31T20:32:41Z",
          "updatedAt": "2022-01-31T20:32:41Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy84tuqd6",
          "commit": {
            "abbreviatedOid": "3f89598"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "This more or less matches what I was thinking, but I think we can spell things a bit more specifically to enable interop.",
          "createdAt": "2021-09-29T21:30:33Z",
          "updatedAt": "2021-09-29T21:49:47Z",
          "comments": [
            {
              "originalPosition": 79,
              "body": "```suggestion\r\n```\r\n\r\nI don't think we need to define this?",
              "createdAt": "2021-09-29T21:30:33Z",
              "updatedAt": "2021-09-29T21:49:47Z"
            },
            {
              "originalPosition": 47,
              "body": "```suggestion\r\ncreated by a given server in the past\r\n```",
              "createdAt": "2021-09-29T21:30:56Z",
              "updatedAt": "2021-09-29T21:49:47Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nshow how this integration allows public metadata to be introduced to\r\n```",
              "createdAt": "2021-09-29T21:31:21Z",
              "updatedAt": "2021-09-29T21:49:47Z"
            },
            {
              "originalPosition": 90,
              "body": "```suggestion\r\na key configuration in a way that clients can retrieve it. This configuration consists\r\nof the server's public key and configuration information for the underlying POPRF.\r\n\r\n~~~\r\nstruct {\r\n   uint8 version;\r\n   uint16 suite;\r\n   uint8 public_key[Ne];\r\n} KeyConfig;\r\n~~~\r\n\r\nKeyConfig.suite corresponds to a POPRF ciphersuite from {{I-D.irtf-cfrg-voprf, Section 4}},\r\nand KeyConfig.public_key corresponds to a serialized public key of length `Ne` bytes \r\n(denoted as a `SerializedElement` in {{I-D.irtf-cfrg-voprf, Section 2}}).\r\n```",
              "createdAt": "2021-09-29T21:34:33Z",
              "updatedAt": "2021-09-29T21:49:47Z"
            },
            {
              "originalPosition": 90,
              "body": "It's hard to interop if we don't describe how configurations are represented, I think.",
              "createdAt": "2021-09-29T21:36:58Z",
              "updatedAt": "2021-09-29T21:49:47Z"
            },
            {
              "originalPosition": 92,
              "body": "I would spell this differently. For example, I might literally frame it in terms of the POPRF protocol, like so:\r\n\r\n```\r\nThe issuance phase proceeds as follows. Let `info` be the agreed upon metadata between client\r\nand server, and let `config` be the server's chosen key configuration.\r\n\r\nFirst, a client configures its verifiable context using `config`:\r\n\r\n~~~\r\nclient_context = SetupVerifiableClient(config.suite, config.public_key)\r\n~~~\r\n\r\nLikewise, the server creates its own context using `config` and the corresponding private key `key`:\r\n\r\n~~~\r\nserver_context = SetupVerifiableServer(config.suite, key, config.public_key)\r\n~~~\r\n\r\nThe client then creates an issuance request as follows:\r\n\r\n~~~\r\nnonce = random(32)\r\nblind, blindedElement = context. Blind(nonce)\r\n~~~\r\n\r\nThe client then sends blindedElement to the server. The server, upon receipt, evaluates the request:\r\n\r\n~~~\r\nevaluatedElement, proof = server_context.Evaluate(key, config.public_key, blindedElement, info)\r\n~~~\r\n\r\nThe server sends both `evaluatedElement` and `proof` to the client. These are concatenated together. As the length of both is fixed, there is no ambiguity in parsing the result.\r\n\r\nThe client then completes issuance as follows:\r\n\r\n~~~\r\noutput = client_context.Finalize(nonce, blind, evaluatedElement, info):\r\n~~~\r\n\r\nThis procedure may fail with an error (`VerifyError` or `DeserializeError`), in which case the issuance is said to have failed. The output of the issuance protocol is the concatenation of `nonce` and `output`, denoted as `token`:\r\n\r\n~~~\r\nstruct {\r\n   uint8 nonce[32];\r\n   uint8 output[Nh]; // Nh is as defined in {{I-D.irtf-cfrg-voprf}}\r\n} Token;\r\n~~~\r\n\r\nIn the redemption phase, the client sends the Token to the server to verify locally. In particular, the server verifies the Token as follows:\r\n\r\n~~~\r\nvalid = server_context.VerifyFinalize(key, token.nonce, token.output, info)\r\n~~~\r\n\r\nRedemption is considered successful if `valid` is true.\r\n```",
              "createdAt": "2021-09-29T21:46:02Z",
              "updatedAt": "2021-09-29T21:49:47Z"
            },
            {
              "originalPosition": 112,
              "body": "I would remove this section entirely.",
              "createdAt": "2021-09-29T21:46:18Z",
              "updatedAt": "2021-09-29T21:49:47Z"
            },
            {
              "originalPosition": 143,
              "body": "Negotiation is a bit odd here, since nothing's negotiated. Maybe this should say that ciphersuites are determined by the server's choice of configuration?",
              "createdAt": "2021-09-29T21:47:00Z",
              "updatedAt": "2021-09-29T21:49:47Z"
            },
            {
              "originalPosition": 90,
              "body": "We should probably also indicate how the server knows which KeyConfig to use for a given request. I don't think this needs to be part of the protocol here, as it may vary. Instead, I'd recommend coming up with a unique way to identify a KeyConfig, e.g., id = SHA256(KeyConfig), and then saying that the wrapper protocol around Privacy Pass can send this to the server if needed for the given application.",
              "createdAt": "2021-09-29T21:49:18Z",
              "updatedAt": "2021-09-29T21:49:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84txjg7",
          "commit": {
            "abbreviatedOid": "3f89598"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-30T14:45:11Z",
          "updatedAt": "2021-09-30T15:08:13Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "What's the version intended to be? Key version?",
              "createdAt": "2021-09-30T14:45:11Z",
              "updatedAt": "2021-09-30T15:08:13Z"
            },
            {
              "originalPosition": 101,
              "body": "Wonder if we should just refer to the triple as the token, and not have to have the client keep a concept of the separate parts? (constructions where the output of issuance ends up just being one bound blob, rather than disparate pieces) Though we can also hide that in the higher level APIs.",
              "createdAt": "2021-09-30T14:47:50Z",
              "updatedAt": "2021-09-30T15:08:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84tx05M",
          "commit": {
            "abbreviatedOid": "3f89598"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-30T15:40:25Z",
          "updatedAt": "2021-09-30T15:40:26Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Version of this key config, so it should probably also include a length of the struct? \ud83e\udd37 ",
              "createdAt": "2021-09-30T15:40:25Z",
              "updatedAt": "2021-09-30T15:40:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84tx1MB",
          "commit": {
            "abbreviatedOid": "3f89598"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-09-30T15:41:25Z",
          "updatedAt": "2021-09-30T15:41:25Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "Yeah, the API should probably just expose a single blob as the token, rather than separate parts. ",
              "createdAt": "2021-09-30T15:41:25Z",
              "updatedAt": "2021-09-30T15:41:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84t2WWs",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-01T17:32:00Z",
          "updatedAt": "2021-10-01T17:32:00Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "In general the form is: \"This specification creates a new page named X in the Y category containing a registry named Z, with the following fields:\".\r\n\r\nIn this case, maybe X = Privacy Pass, Y = Privacy Pass, Z = \"Cipher Suites\".\r\n\r\nAlso think about whether your cipher suites need a numeric identifier, or whether it is sufficient to give them strings.",
              "createdAt": "2021-10-01T17:32:00Z",
              "updatedAt": "2021-10-05T14:32:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84t-dB8",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T12:01:56Z",
          "updatedAt": "2021-10-05T12:05:49Z",
          "comments": [
            {
              "originalPosition": 157,
              "body": "```suggestion\r\nblind, blindedElement = client_context.Blind(nonce)\r\n```",
              "createdAt": "2021-10-05T12:01:56Z",
              "updatedAt": "2021-10-05T12:05:49Z"
            },
            {
              "originalPosition": 110,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-10-05T12:04:46Z",
              "updatedAt": "2021-10-05T12:05:49Z"
            },
            {
              "originalPosition": 110,
              "body": "I guess one can version above this, so maybe it's not necessary here.",
              "createdAt": "2021-10-05T12:05:01Z",
              "updatedAt": "2021-10-05T12:05:49Z"
            },
            {
              "originalPosition": 118,
              "body": "```suggestion\r\n```",
              "createdAt": "2021-10-05T12:05:12Z",
              "updatedAt": "2021-10-05T12:05:49Z"
            },
            {
              "originalPosition": 211,
              "body": "Why do we need these ciphersuites at all? Aren't they redundant with the POPRF suite? ",
              "createdAt": "2021-10-05T12:05:47Z",
              "updatedAt": "2021-10-05T12:05:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84t_M55",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T14:38:46Z",
          "updatedAt": "2021-10-05T14:38:46Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "I think we do need a new IANA registry.  Without a registry, we would have to Update one or more RFCs every time we want to add a ciphersuite, which is laborious to execute and confusing to read.\r\n\r\nWhere that registry should be created depends on its intended contents.  If all future VOPRF suites as conceived in the VOPRF draft will continue to be exactly what you want for Privacy Pass, then the VOPRF draft can open the registry.  Otherwise (e.g. if we envision extending Privacy Pass to publicly verifiable ciphersuites), we'll need to define it here.\r\n\r\nAt the moment, the latter seems more likely.",
              "createdAt": "2021-10-05T14:38:46Z",
              "updatedAt": "2021-10-05T14:38:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84t_S_R",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T14:57:07Z",
          "updatedAt": "2021-10-05T14:57:08Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "Yeah, for example in a future world where we have a Blind BLS suite and a POPRF suite, it seems like we'll want some containing ciphersuite that refers to one or the other.",
              "createdAt": "2021-10-05T14:57:08Z",
              "updatedAt": "2021-10-05T14:57:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84t_TIq",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T14:57:36Z",
          "updatedAt": "2021-10-05T14:57:50Z",
          "comments": [
            {
              "originalPosition": 219,
              "body": "Assuming we want to do a separate IANA registry, we might want to pare down the ones that are initially defined?",
              "createdAt": "2021-10-05T14:57:36Z",
              "updatedAt": "2021-10-05T14:57:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84t__x6",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:38:50Z",
          "updatedAt": "2021-10-05T17:38:50Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "Sorry, I don't really follow. Why would those things be in the same registry? This document is really just a thin wrapper around the POPRF, and no updates would be needed if new POPRF suites were added. In other words, the POPRF document owns the registry for POPRF suites. \r\n\r\nPrivacy Pass variants based on blind signatures would be thin wrappers around some future blind signature protocol, that itself would have its own registry (or that variant of Privacy Pass would have its own registry). Either way, it seems unnecessary here.",
              "createdAt": "2021-10-05T17:38:50Z",
              "updatedAt": "2021-10-05T17:39:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84uABvu",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:47:18Z",
          "updatedAt": "2021-10-05T17:47:18Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "Perhaps PMBTokens (an alternative to VOPRF that also matches the synchronous model) is a clearer example than Blind Signatures (which can also be made to fit into the synchronous model, but perhaps less elegantly).",
              "createdAt": "2021-10-05T17:47:18Z",
              "updatedAt": "2021-10-05T17:47:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84uADGT",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T17:51:13Z",
          "updatedAt": "2021-10-05T17:51:14Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "I see your point, but it's not clear to me we actually want a single registry to list different \"modes\" of privacy pass, e.g., one without private metadata (POPRF) and one with private metadata (PMBTokens). Why not just make that a separate thing altogether? What's the value of merging these things?",
              "createdAt": "2021-10-05T17:51:13Z",
              "updatedAt": "2021-10-05T17:51:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84uATo2",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T18:20:26Z",
          "updatedAt": "2021-10-05T18:20:26Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "At some layer we need to indicate what protocol is being used for a web/HTTP API. Be it PrivacyPassVOPRFP521 or PrivacyPassCoolPostQuantum or PrivacyPassBLS. Seems like something that the PrivacyPass WG should define somewhere as things that higher level things point to, though maybe we don't have that in the Integration doc and put it somewhere else?",
              "createdAt": "2021-10-05T18:20:26Z",
              "updatedAt": "2021-10-05T18:20:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84uAekO",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:02:52Z",
          "updatedAt": "2021-10-05T19:02:53Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "The goal mentioned in the proposed schedule is to support ecosystems containing a mixture of clients and issuers that support POPRF and non-POPRF ciphersuites.  That means one way or another, different ciphersuite families need to be accessible from the same server identity.\r\n\r\nFor clarity, it might be more helpful to frame this question in terms of the specific structs in the HTTP API draft.",
              "createdAt": "2021-10-05T19:02:52Z",
              "updatedAt": "2021-10-05T19:02:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84uAfOq",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-05T19:05:52Z",
          "updatedAt": "2021-10-05T19:05:53Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "> The goal mentioned in the proposed schedule is to support ecosystems containing a mixture of clients and issuers that support POPRF and non-POPRF ciphersuites. That means one way or another, different ciphersuite families need to be accessible from the same server identity.\r\n\r\nSure, but they could so by using separate types of key configurations or otherwise making this decision at the application layer. The goal of the schedule doesn't seem to require that a joint registry be created.\r\n\r\n> For clarity, it might be more helpful to frame this question in terms of the specific structs in the HTTP API draft.\r\n\r\nI'm not sure. I expect many users of Privacy Pass to just use the wire formats described in this doc.",
              "createdAt": "2021-10-05T19:05:53Z",
              "updatedAt": "2021-10-05T19:05:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84uEpIi",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-06T16:29:28Z",
          "updatedAt": "2021-10-06T16:29:28Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "> Be it PrivacyPassVOPRFP521 or PrivacyPassCoolPostQuantum or PrivacyPassBLS. Seems like something that the PrivacyPass WG should define somewhere as things that higher level things point to\r\n\r\n@dvorak42 I guess what gives me pause is that putting everything behind a single registry implies that all values in that registry have similar properties, but that's not the case here. In contrast to, say, TLS algorithm registries, which are really just different algorithms with the same set of features. The things we're considering merging here have fundamentally different features (or at least they do in my opinion), so it's not clear to me that merging them is appropriate. (Sorry if I'm not making my thinking clear!)",
              "createdAt": "2021-10-06T16:29:28Z",
              "updatedAt": "2021-10-06T16:29:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84uZ18X",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-13T12:49:51Z",
          "updatedAt": "2021-10-13T12:49:51Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "Bump?",
              "createdAt": "2021-10-13T12:49:51Z",
              "updatedAt": "2021-10-13T12:49:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84ugJqF",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T19:45:23Z",
          "updatedAt": "2021-10-14T19:45:23Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "@chris-wood Maybe you could send a PR that updates draft-ietf-privacypass-http-api in the way you're thinking?",
              "createdAt": "2021-10-14T19:45:23Z",
              "updatedAt": "2021-10-14T19:45:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84ugL4n",
          "commit": {
            "abbreviatedOid": "db0af02"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-10-14T19:55:50Z",
          "updatedAt": "2021-10-14T19:55:51Z",
          "comments": [
            {
              "originalPosition": 211,
              "body": "Sure: https://github.com/ietf-wg-privacypass/base-drafts/pull/85",
              "createdAt": "2021-10-14T19:55:50Z",
              "updatedAt": "2021-10-14T19:55:51Z"
            }
          ]
        }
      ]
    },
    {
      "number": 85,
      "id": "PR_kwDODeTEy84tOCWS",
      "title": "Example integration into HTTP doc",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/85",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This versions at the application layer. We could have a way for servers to advertise the variants they support if needed, which would be another simple resource to add. ",
      "createdAt": "2021-10-14T19:55:43Z",
      "updatedAt": "2021-12-14T00:18:21Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "920b6e608e2774837ae23487a4d772d6f7a2b5e3",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/example-usage",
      "headRefOid": "e92e07ad03f4ca5163b81106f4f08e94a0efc493",
      "closedAt": "2021-12-14T00:18:21Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "body": "FWIW, this looks good to me, except that we probably want to reference the P384 ciphersuite following the recent change in #83.",
          "createdAt": "2021-10-19T12:44:25Z",
          "updatedAt": "2021-10-19T12:44:25Z"
        },
        {
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this ready to be merged? Looks like it's only listed as a draft?\r\n\r\nAny reason for the change to the endpoints from being a single endpoint to per-stage? I wonder if we need to specify that much or let the server configuration dictate what endpoint(s) to hit.",
          "createdAt": "2021-10-19T13:32:24Z",
          "updatedAt": "2021-10-19T13:32:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 86,
      "id": "PR_kwDODeTEy84vxx2f",
      "title": "Refactor architecture document into PAT-like protocols and entities",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/86",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This reshuffles quite a bit to frame Privacy Pass as two protocols -- issuance and redemption -- run between Clients, Mediators, Issuers, and Origins. \r\n\r\nFirst draft, so there may be things we want to rephrase or reflow. \r\n\r\nRendered view of this PR [is here](https://ietf-wg-privacypass.github.io/base-drafts/caw/arch-refactor/draft-ietf-privacypass-architecture.html).",
      "createdAt": "2021-12-13T19:12:16Z",
      "updatedAt": "2022-01-31T18:18:03Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "920b6e608e2774837ae23487a4d772d6f7a2b5e3",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/arch-refactor",
      "headRefOid": "b9f4685549adfea4ead4cc67421f74953cc22a06",
      "closedAt": "2022-01-31T18:18:03Z",
      "mergedAt": "2022-01-31T18:18:03Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "99589afc196039fa7907877bf2ab0288c115b84b"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Whitespace errors?\r\n```\r\ndraft-ietf-privacypass-architecture.md contains trailing whitespace\r\n48\r\n*** Run 'make fix-lint' to automatically fix some errors\r\n49\r\nmake: *** [lib/main.mk:205: lint-whitespace] Error 1\r\n```",
          "createdAt": "2021-12-17T19:00:50Z",
          "updatedAt": "2021-12-17T19:00:50Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@tfpauly fixed!",
          "createdAt": "2021-12-17T19:02:01Z",
          "updatedAt": "2021-12-17T19:02:01Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging this per the discussion during the interim meeting today. ",
          "createdAt": "2022-01-31T18:17:56Z",
          "updatedAt": "2022-01-31T18:17:56Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy84xgvC7",
          "commit": {
            "abbreviatedOid": "c44ed07"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T19:30:12Z",
          "updatedAt": "2021-12-13T19:41:40Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nsuch as through the use of long-term cookies, are not privacy-friendly\r\n```",
              "createdAt": "2021-12-13T19:30:12Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 63,
              "body": "Does this need to say \"original\"?\r\n\r\n```suggestion\r\nThe most basic Privacy Pass protocol provides a set of cross-origin\r\n```",
              "createdAt": "2021-12-13T19:31:20Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 73,
              "body": "I think we should mention that the issuer/mediator can be combined as one entity. Perhaps, say these are three functions, rather than three entities?",
              "createdAt": "2021-12-13T19:32:35Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 99,
              "body": "Perhaps the Client -> Mediator flow should indicate a first authentication/validation step?",
              "createdAt": "2021-12-13T19:33:26Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 189,
              "body": "Maybe call this Issuer identity? And maybe list it as the second item?",
              "createdAt": "2021-12-13T19:34:30Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 99,
              "body": "I like the later diagram that has \"attest\"",
              "createdAt": "2021-12-13T19:35:02Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 73,
              "body": "We can also bike shed on the \"mediator\" name. I do like the \"attest\" verb you are using elsewhere. \"Attestor\"?",
              "createdAt": "2021-12-13T19:35:39Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 391,
              "body": "This should be noted as optional, if it's part of the description at all. I'd be tempted to not mention it as a top-level responsibility, but rather say that the mediator can attest to more than just validity of client, but can attest based on state it knows.",
              "createdAt": "2021-12-13T19:37:17Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 394,
              "body": "```suggestion\r\nsome issuance protocols that enforce rate limits. For example, the Issuer may\r\n```",
              "createdAt": "2021-12-13T19:37:23Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 965,
              "body": "I think we should be clear that this is only need for non-interactive passes.",
              "createdAt": "2021-12-13T19:39:41Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 980,
              "body": "We should mention tokens being scoped to an origin here, or being interactive, as a way to avoid this.",
              "createdAt": "2021-12-13T19:40:20Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 1003,
              "body": "AV and SRR are no longer defined in the document.",
              "createdAt": "2021-12-13T19:40:45Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            },
            {
              "originalPosition": 1091,
              "body": "I do like the approach of having clients limit the number of non-interactive cross-origin tokens they're willing to maintain from different Issuers.",
              "createdAt": "2021-12-13T19:41:30Z",
              "updatedAt": "2021-12-13T19:41:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xg3iS",
          "commit": {
            "abbreviatedOid": "4055e17"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T20:03:57Z",
          "updatedAt": "2021-12-13T20:03:57Z",
          "comments": [
            {
              "originalPosition": 189,
              "body": "Yep, that's better \ud83d\udc4d ",
              "createdAt": "2021-12-13T20:03:57Z",
              "updatedAt": "2021-12-13T20:03:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xg-SR",
          "commit": {
            "abbreviatedOid": "4055e17"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T20:34:42Z",
          "updatedAt": "2021-12-13T20:34:43Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "```suggestion\r\n Client        Attestor          Issuer          Origin\r\n\r\n    <---------------------------------------- Challenge \\\r\n                                                        |\r\n+--------------------------------------------\\          |\r\n| Attest --->                          |          |\r\n| TokenRequest ------------------>       |          |\r\n|                                 (validate) | Issuance | Redemption\r\n|                                 (evaluate) |   Flow   |   Flow\r\n|   <------------ TokenResponse      |          |\r\n---------------------------------------------/          |\r\n                                                        |\r\n```",
              "createdAt": "2021-12-13T20:34:43Z",
              "updatedAt": "2021-12-13T20:34:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xg_7i",
          "commit": {
            "abbreviatedOid": "4055e17"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T20:42:08Z",
          "updatedAt": "2021-12-13T20:42:08Z",
          "comments": [
            {
              "originalPosition": 354,
              "body": "Can we call this Attester, have only one function, and talk about how the attester can attest to other attributes than client identity/legitimacy. For example, this could be geolocation or client state/rate limiting.",
              "createdAt": "2021-12-13T20:42:08Z",
              "updatedAt": "2021-12-13T20:42:08Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xiV5b",
          "commit": {
            "abbreviatedOid": "4055e17"
          },
          "author": "janaiyengar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "A few comments, but this is a great cut! Thanks, Chris!",
          "createdAt": "2021-12-14T07:08:17Z",
          "updatedAt": "2021-12-14T07:51:36Z",
          "comments": [
            {
              "originalPosition": 106,
              "body": "I definitely like this new figure better.",
              "createdAt": "2021-12-14T07:08:18Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 119,
              "body": "This and the following points all seem unnecessary in the Intro, given the preceding sentence that says that the document will describe ecosystem considerations.",
              "createdAt": "2021-12-14T07:13:32Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 339,
              "body": "```suggestion\r\nDepending on the use case, issuance may require some form of Client\r\n```",
              "createdAt": "2021-12-14T07:20:58Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 362,
              "body": "```suggestion\r\nAttestation is the process by which the Clients bear witness, confirm, or\r\n```",
              "createdAt": "2021-12-14T07:22:48Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 417,
              "body": "This is the first time \"Privacy Pass key pair\" is mentioned. Given that this key pair is described below, perhaps rename the section \"Privacy Pass Keys\"?\r\n\r\nAlso, server public key should be Issuer public key, right?",
              "createdAt": "2021-12-14T07:25:56Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 420,
              "body": "unclear: for ensuring what?",
              "createdAt": "2021-12-14T07:29:59Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 594,
              "body": "```suggestion\r\nreceptive to extensions that expand the current set of functionalities.\r\n```",
              "createdAt": "2021-12-14T07:31:49Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 596,
              "body": "I don't understand this requirement -- why SHOULD extensions modify this document? Also, there's a Redemption protocol and an Issuance protocol -- there is no mention of the Privacy Pass protocol so far in this doc.",
              "createdAt": "2021-12-14T07:32:40Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 607,
              "body": "```suggestion\r\nthat can easily measure and maximize the relative anonymity of any\r\n```",
              "createdAt": "2021-12-14T07:37:04Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 711,
              "body": "```suggestion\r\nIssuers SHOULD invoke key rotation for\r\na period of time between 1 and 12 weeks. Key rotations\r\n```\r\nRECOMMENDED and SHOULD have the same semantic, and SHOULD seems more direct here. Also, if there's a SHOULD, the recommendation should be clear.",
              "createdAt": "2021-12-14T07:42:03Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 716,
              "body": "```suggestion\r\nregular cycle to reduce the harmfulness of an Issuer key\r\n```",
              "createdAt": "2021-12-14T07:42:46Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 741,
              "body": "```suggestion\r\nWith a large number of Clients, a minimum of one week gives a large enough window for\r\nClients to participate in the Issuance protocol and thus enjoy the\r\nanonymity guarantees of being part of a larger group. A maximum of\r\n```",
              "createdAt": "2021-12-14T07:44:04Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 742,
              "body": "```suggestion\r\n12 weeks limits the damage caused by a key compromise. If an Issuer\r\n```",
              "createdAt": "2021-12-14T07:45:14Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            },
            {
              "originalPosition": 752,
              "body": "```suggestion\r\na Client for a token from each Issuer, Origins can learn information about\r\n```",
              "createdAt": "2021-12-14T07:47:45Z",
              "updatedAt": "2021-12-14T07:51:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xkK2n",
          "commit": {
            "abbreviatedOid": "9ecd592"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T14:20:57Z",
          "updatedAt": "2021-12-14T14:20:57Z",
          "comments": [
            {
              "originalPosition": 420,
              "body": "I'm not sure -- this is leftover text, so I'll just remove it.",
              "createdAt": "2021-12-14T14:20:57Z",
              "updatedAt": "2021-12-14T14:20:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xkNjQ",
          "commit": {
            "abbreviatedOid": "9ecd592"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T14:28:42Z",
          "updatedAt": "2021-12-14T14:28:42Z",
          "comments": [
            {
              "originalPosition": 596,
              "body": "Rephrased!",
              "createdAt": "2021-12-14T14:28:42Z",
              "updatedAt": "2021-12-14T14:28:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xlm22",
          "commit": {
            "abbreviatedOid": "c02812e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T19:24:54Z",
          "updatedAt": "2021-12-14T19:24:56Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "```suggestion\r\nAt a high level, Privacy Pass is composed of two protocols: issuance\r\nand redemption.\r\n\r\nIssuance is a protocol between a Client and two functions: Attester and Issuer.\r\nThe Attester and Issuer can be functions operated by the same protocol participant,\r\nbut can also be implemented separately. The Issuer is responsible for issuing tokens\r\nin response to requests from Clients. The Attester is responsible for attesting\r\nproperties about the Client for which tokens are issued. The Issuer needs to be\r\ntrusted by the server that later redeems the token. The Attester needs to either be\r\noperated by the Issuer, or be operated by an entity the Issuer trusts to perform valid\r\nattestation. Clients might prefer to select different Attesters, separate from the\r\nIssuer, to be able to use preferred authentication methods or improve privacy by\r\nnot directly communicating with an Issuer. Depending on the information being attested, Attesters may also store state about individual Clients, such as the number of\r\noverall tokens issued thus far. As an example of an Issuance protocol, in the\r\noriginal Privacy Pass protocol {{PPSRV}}, tokens were only issued to Clients\r\nthat solved CAPTCHAs. In this context, the Attester attested that some client\r\nsolved a CAPTCHA and the resulting token produced by the Issuer was proof of\r\nthis fact.\r\n```",
              "createdAt": "2021-12-14T19:24:54Z",
              "updatedAt": "2021-12-14T19:24:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xmFDu",
          "commit": {
            "abbreviatedOid": "33fbe78"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-14T21:33:57Z",
          "updatedAt": "2021-12-14T21:33:57Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "Applied with some tweaks",
              "createdAt": "2021-12-14T21:33:57Z",
              "updatedAt": "2021-12-14T21:33:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xnC9R",
          "commit": {
            "abbreviatedOid": "33fbe78"
          },
          "author": "janaiyengar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "A few comments; thanks for the quick turnaround!",
          "createdAt": "2021-12-15T05:46:57Z",
          "updatedAt": "2021-12-15T06:09:52Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "```suggestion\r\nand redemption.\r\n\r\nThe issuance protocol runs between a Client and two network functions in the Privacy \r\nPass architecture: Attestation and Issuance. These two network functions can be\r\nimplemented by the\r\n```",
              "createdAt": "2021-12-15T05:46:57Z",
              "updatedAt": "2021-12-15T06:09:52Z"
            },
            {
              "originalPosition": 19,
              "body": "Move these descriptions of Issuer and Attester to right after they are introducted above (after `two network functions: Attester and Issuer`).\r\n\r\nAlso, s/server/Origin",
              "createdAt": "2021-12-15T05:48:28Z",
              "updatedAt": "2021-12-15T06:09:52Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nredeems the token. Attestation can be performed by the Issuer or by an\r\nAttester that is trusted by the Issuer.\r\n```",
              "createdAt": "2021-12-15T05:54:10Z",
              "updatedAt": "2021-12-15T06:09:52Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\nto be able to use preferred authentication methods or to improve privacy by communicating\r\nindirectly with an Issuer, proxied or mediated through an Attester. Depending on the information being\r\n```",
              "createdAt": "2021-12-15T05:56:33Z",
              "updatedAt": "2021-12-15T06:09:52Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\ndirectly communicating with an Issuer. Depending on the attestation,\r\nAttesters can store state about a Client, such as the\r\n```",
              "createdAt": "2021-12-15T06:01:06Z",
              "updatedAt": "2021-12-15T06:09:52Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\n  attested to by the Attester.\r\n```",
              "createdAt": "2021-12-15T06:02:19Z",
              "updatedAt": "2021-12-15T06:09:52Z"
            },
            {
              "originalPosition": 93,
              "body": "```suggestion\r\n- Attester: An entity that attests to properties of Client for the\r\n  purposes of token issuance.\r\n```\r\n```suggestion\r\n- Attester: An entity that attests to the properties of a Client required by an Issuer\r\n  for token issuance.\r\n```",
              "createdAt": "2021-12-15T06:04:15Z",
              "updatedAt": "2021-12-15T06:09:52Z"
            },
            {
              "originalPosition": 167,
              "body": "`bear witness` seems strange. What can a Client bearing witness to about itself? Maybe this should be `by which an Attester bears witness to, confirms, or authenticates a Client so as to verify a property about the Client that is required for Issuance.`",
              "createdAt": "2021-12-15T06:07:19Z",
              "updatedAt": "2021-12-15T06:09:52Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xpVHB",
          "commit": {
            "abbreviatedOid": "83feb75"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T14:47:03Z",
          "updatedAt": "2021-12-15T14:47:03Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "As discussed, I don't think we should describe the Attester as a proxy.",
              "createdAt": "2021-12-15T14:47:03Z",
              "updatedAt": "2021-12-15T14:47:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xpWhT",
          "commit": {
            "abbreviatedOid": "7700fd4"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T14:51:03Z",
          "updatedAt": "2021-12-15T14:51:03Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "The descriptions of these roles _are_ right after they're introduced, so I'm not sure what this looking for here. Leave a suggestion?",
              "createdAt": "2021-12-15T14:51:03Z",
              "updatedAt": "2021-12-15T14:51:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xpXAl",
          "commit": {
            "abbreviatedOid": "ba8d3ab"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T14:52:24Z",
          "updatedAt": "2021-12-15T14:52:24Z",
          "comments": [
            {
              "originalPosition": 167,
              "body": "Yeah, that's better!",
              "createdAt": "2021-12-15T14:52:24Z",
              "updatedAt": "2021-12-15T14:52:24Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xqEi6",
          "commit": {
            "abbreviatedOid": "ba8d3ab"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T17:16:34Z",
          "updatedAt": "2021-12-15T17:26:57Z",
          "comments": [
            {
              "originalPosition": 361,
              "body": "Maybe later on, but should it be explicitly called out that some forms of the protocol might collapse this into another role?",
              "createdAt": "2021-12-15T17:16:34Z",
              "updatedAt": "2021-12-15T17:26:57Z"
            },
            {
              "originalPosition": 390,
              "body": "nit: than the",
              "createdAt": "2021-12-15T17:22:01Z",
              "updatedAt": "2021-12-15T17:26:57Z"
            },
            {
              "originalPosition": 372,
              "body": "Maybe worth splitting out client identity and client issuance state?",
              "createdAt": "2021-12-15T17:24:38Z",
              "updatedAt": "2021-12-15T17:26:57Z"
            },
            {
              "originalPosition": 122,
              "body": "Maybe worth moving Origin to the left to match the other figures?",
              "createdAt": "2021-12-15T17:25:09Z",
              "updatedAt": "2021-12-15T17:26:57Z"
            },
            {
              "originalPosition": 82,
              "body": "cross-origin is a little odd now, since the per-origin tokens aren't quite \"cross-origin\" in the traditional sense versus cross between Origin and Issuer.",
              "createdAt": "2021-12-15T17:26:33Z",
              "updatedAt": "2021-12-15T17:26:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xqJPP",
          "commit": {
            "abbreviatedOid": "ba8d3ab"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T17:33:43Z",
          "updatedAt": "2021-12-15T17:33:44Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "Hmm, I don't follow. Can you elaborate?",
              "createdAt": "2021-12-15T17:33:43Z",
              "updatedAt": "2021-12-15T17:33:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xqJRw",
          "commit": {
            "abbreviatedOid": "ba8d3ab"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T17:33:52Z",
          "updatedAt": "2021-12-15T17:33:53Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Sure, I'll play with it and see what works.",
              "createdAt": "2021-12-15T17:33:52Z",
              "updatedAt": "2021-12-15T17:33:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xzYZQ",
          "commit": {
            "abbreviatedOid": "b39ceb8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-17T19:01:02Z",
          "updatedAt": "2021-12-17T19:01:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 87,
      "id": "PR_kwDODeTEy84vymk_",
      "title": "Aligned issuance protocol",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/87",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Built on the [latest architecture change](#86) and [HTTP-auth mechanism](https://github.com/tfpauly/privacy-proxy/blob/main/draft-pauly-privacypass-auth-scheme.md), and building on #83 as the opinionated approach. This includes both the POPRF variant and RSA variants.",
      "createdAt": "2021-12-13T23:09:55Z",
      "updatedAt": "2022-01-31T20:32:57Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "920b6e608e2774837ae23487a4d772d6f7a2b5e3",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/pp-issuance",
      "headRefOid": "aec91490d961d6ffb446769d1939e69511586d51",
      "closedAt": "2022-01-31T20:32:57Z",
      "mergedAt": "2022-01-31T20:32:57Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "ca578b74eebf8372fc5d75f1d325c9f670b30afb"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy84xhiXE",
          "commit": {
            "abbreviatedOid": "5ccc88b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-13T23:44:26Z",
          "updatedAt": "2021-12-14T00:44:10Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nabbrev: PP Issuance\r\n```",
              "createdAt": "2021-12-13T23:44:27Z",
              "updatedAt": "2021-12-14T00:44:10Z"
            },
            {
              "originalPosition": 1121,
              "body": "This would be a different token type, right?\r\n```suggestion\r\n    uint16_t token_type = 0x0002\r\n```",
              "createdAt": "2021-12-14T00:42:43Z",
              "updatedAt": "2021-12-14T00:44:10Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\r\n{{!BLINDRSA=I-D.irtf-cfrg-rsa-blind-signatures}}.\r\n```",
              "createdAt": "2021-12-14T00:44:07Z",
              "updatedAt": "2021-12-14T00:44:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xnNCN",
          "commit": {
            "abbreviatedOid": "26f381d"
          },
          "author": "janaiyengar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM, a couple of nits.",
          "createdAt": "2021-12-15T06:37:51Z",
          "updatedAt": "2021-12-15T06:39:07Z",
          "comments": [
            {
              "originalPosition": 1184,
              "body": "```suggestion\r\nThis document outlines how to instantiate the Issuance protocol\r\n```",
              "createdAt": "2021-12-15T06:37:52Z",
              "updatedAt": "2021-12-15T06:39:07Z"
            },
            {
              "originalPosition": 1188,
              "body": "```suggestion\r\nconcerns in a multi-Client and multi-Issuer setting are deferred to the\r\n```",
              "createdAt": "2021-12-15T06:38:09Z",
              "updatedAt": "2021-12-15T06:39:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xpnk7",
          "commit": {
            "abbreviatedOid": "e435a2e"
          },
          "author": "alxdavids",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It looks fine to me \ud83d\udc4d ",
          "createdAt": "2021-12-15T15:40:48Z",
          "updatedAt": "2021-12-15T15:41:53Z",
          "comments": [
            {
              "originalPosition": 1185,
              "body": "Should these considerations also ref the blind RSA doc?",
              "createdAt": "2021-12-15T15:40:49Z",
              "updatedAt": "2021-12-15T15:41:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xprnJ",
          "commit": {
            "abbreviatedOid": "e435a2e"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-15T15:53:49Z",
          "updatedAt": "2021-12-15T15:53:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy84xqCof",
          "commit": {
            "abbreviatedOid": "e435a2e"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T17:09:53Z",
          "updatedAt": "2021-12-15T17:13:38Z",
          "comments": [
            {
              "originalPosition": 459,
              "body": "Should this be token_type or the struct updated up above?",
              "createdAt": "2021-12-15T17:09:53Z",
              "updatedAt": "2021-12-15T17:13:38Z"
            },
            {
              "originalPosition": 893,
              "body": "nit: Same as above.",
              "createdAt": "2021-12-15T17:11:59Z",
              "updatedAt": "2021-12-15T17:13:38Z"
            },
            {
              "originalPosition": 1234,
              "body": "Public -> Publicly Verifiable since we have a  Public Metadata column now?",
              "createdAt": "2021-12-15T17:13:24Z",
              "updatedAt": "2021-12-15T17:13:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xqFuC",
          "commit": {
            "abbreviatedOid": "e435a2e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T17:20:46Z",
          "updatedAt": "2021-12-15T17:20:46Z",
          "comments": [
            {
              "originalPosition": 459,
              "body": "Yep!",
              "createdAt": "2021-12-15T17:20:46Z",
              "updatedAt": "2021-12-15T17:20:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xqFz1",
          "commit": {
            "abbreviatedOid": "e435a2e"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T17:21:06Z",
          "updatedAt": "2021-12-15T17:21:06Z",
          "comments": [
            {
              "originalPosition": 1234,
              "body": "Yep, good suggestion.",
              "createdAt": "2021-12-15T17:21:06Z",
              "updatedAt": "2021-12-15T17:21:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xrQHR",
          "commit": {
            "abbreviatedOid": "f87c7f9"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T21:27:44Z",
          "updatedAt": "2021-12-15T21:27:44Z",
          "comments": [
            {
              "originalPosition": 1196,
              "body": "```suggestion\r\n## Token Type\r\n\r\nThis document updates the \"Token Type\" Registry with the following values.\r\n```",
              "createdAt": "2021-12-15T21:27:44Z",
              "updatedAt": "2021-12-15T21:27:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xrQYo",
          "commit": {
            "abbreviatedOid": "f87c7f9"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T21:29:04Z",
          "updatedAt": "2021-12-15T21:29:10Z",
          "comments": [
            {
              "originalPosition": 1236,
              "body": "```suggestion\r\n{: #aeadid-values title=\"Token Types\"}\r\n\r\n## Media Types\r\n\r\nThis specification defines the following protocol messages, along with their\r\ncorresponding media types:\r\n\r\n- TokenRequest: \"message/token-request\"\r\n- TokenResponse: \"message/token-response\"\r\n\r\nThe definition for each media type is in the following subsections.\r\n\r\n### \"message/token-request\" media type\r\n\r\nType name:\r\n\r\n: message\r\n\r\nSubtype name:\r\n\r\n: token-request\r\n\r\nRequired parameters:\r\n\r\n: N/A\r\n\r\nOptional parameters:\r\n\r\n: None\r\n\r\nEncoding considerations:\r\n\r\n: only \"8bit\" or \"binary\" is permitted\r\n\r\nSecurity considerations:\r\n\r\n: see {{issuance}}\r\n\r\nInteroperability considerations:\r\n\r\n: N/A\r\n\r\nPublished specification:\r\n\r\n: this specification\r\n\r\nApplications that use this media type:\r\n\r\n: N/A\r\n\r\nFragment identifier considerations:\r\n\r\n: N/A\r\n\r\nAdditional information:\r\n\r\n: <dl>\r\n  <dt>Magic number(s):</dt><dd>N/A</dd>\r\n  <dt>Deprecated alias names for this type:</dt><dd>N/A</dd>\r\n  <dt>File extension(s):</dt><dd>N/A</dd>\r\n  <dt>Macintosh file type code(s):</dt><dd>N/A</dd>\r\n  </dl>\r\n\r\nPerson and email address to contact for further information:\r\n\r\n: see Authors' Addresses section\r\n\r\nIntended usage:\r\n\r\n: COMMON\r\n\r\nRestrictions on usage:\r\n\r\n: N/A\r\n\r\nAuthor:\r\n\r\n: see Authors' Addresses section\r\n\r\nChange controller:\r\n\r\n: IESG\r\n\r\n### \"message/token-response\" media type\r\n\r\nType name:\r\n\r\n: message\r\n\r\nSubtype name:\r\n\r\n: access-token-response\r\n\r\nRequired parameters:\r\n\r\n: N/A\r\n\r\nOptional parameters:\r\n\r\n: None\r\n\r\nEncoding considerations:\r\n\r\n: only \"8bit\" or \"binary\" is permitted\r\n\r\nSecurity considerations:\r\n\r\n: see {{issuance}}\r\n\r\nInteroperability considerations:\r\n\r\n: N/A\r\n\r\nPublished specification:\r\n\r\n: this specification\r\n\r\nApplications that use this media type:\r\n\r\n: N/A\r\n\r\nFragment identifier considerations:\r\n\r\n: N/A\r\n\r\nAdditional information:\r\n\r\n: <dl>\r\n  <dt>Magic number(s):</dt><dd>N/A</dd>\r\n  <dt>Deprecated alias names for this type:</dt><dd>N/A</dd>\r\n  <dt>File extension(s):</dt><dd>N/A</dd>\r\n  <dt>Macintosh file type code(s):</dt><dd>N/A</dd>\r\n  </dl>\r\n\r\nPerson and email address to contact for further information:\r\n\r\n: see Authors' Addresses section\r\n\r\nIntended usage:\r\n\r\n: COMMON\r\n\r\nRestrictions on usage:\r\n\r\n: N/A\r\n\r\nAuthor:\r\n\r\n: see Authors' Addresses section\r\n\r\nChange controller:\r\n\r\n: IESG\r\n```",
              "createdAt": "2021-12-15T21:29:04Z",
              "updatedAt": "2021-12-15T21:29:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xriUY",
          "commit": {
            "abbreviatedOid": "f8f0748"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T23:08:31Z",
          "updatedAt": "2021-12-15T23:08:32Z",
          "comments": [
            {
              "originalPosition": 730,
              "body": "```suggestion\r\n- \"token_type\" is a 2-octet integer, which matches the type in the challenge.\r\n```",
              "createdAt": "2021-12-15T23:08:32Z",
              "updatedAt": "2021-12-15T23:08:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xriYP",
          "commit": {
            "abbreviatedOid": "f8f0748"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T23:08:56Z",
          "updatedAt": "2021-12-15T23:08:56Z",
          "comments": [
            {
              "originalPosition": 506,
              "body": "Does it make sense to refer to versions here?",
              "createdAt": "2021-12-15T23:08:56Z",
              "updatedAt": "2021-12-15T23:08:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xriay",
          "commit": {
            "abbreviatedOid": "f8f0748"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T23:09:10Z",
          "updatedAt": "2021-12-15T23:09:10Z",
          "comments": [
            {
              "originalPosition": 768,
              "body": "Same question about version",
              "createdAt": "2021-12-15T23:09:10Z",
              "updatedAt": "2021-12-15T23:09:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xrigj",
          "commit": {
            "abbreviatedOid": "f8f0748"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-15T23:09:46Z",
          "updatedAt": "2021-12-15T23:10:18Z",
          "comments": [
            {
              "originalPosition": 850,
              "body": "```suggestion\r\n# Security considerations {#security-considerations}\r\n\r\n```",
              "createdAt": "2021-12-15T23:09:46Z",
              "updatedAt": "2021-12-15T23:10:18Z"
            },
            {
              "originalPosition": 938,
              "body": "```suggestion\r\n: see {{security-considerations}}\r\n```",
              "createdAt": "2021-12-15T23:09:53Z",
              "updatedAt": "2021-12-15T23:10:18Z"
            },
            {
              "originalPosition": 1213,
              "body": "```suggestion\r\n: see {{security-considerations}}\r\n```",
              "createdAt": "2021-12-15T23:10:06Z",
              "updatedAt": "2021-12-15T23:10:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xrlIV",
          "commit": {
            "abbreviatedOid": "87c941f"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Aligning terminology...",
          "createdAt": "2021-12-15T23:29:01Z",
          "updatedAt": "2021-12-15T23:32:26Z",
          "comments": [
            {
              "originalPosition": 440,
              "body": "```suggestion\r\n   uint8_t issuer_key_id;\r\n```",
              "createdAt": "2021-12-15T23:29:02Z",
              "updatedAt": "2021-12-15T23:32:27Z"
            },
            {
              "originalPosition": 466,
              "body": "```suggestion\r\n- \"issuer_key_id\" is the least significant byte of the `key_id`.\r\n```",
              "createdAt": "2021-12-15T23:29:36Z",
              "updatedAt": "2021-12-15T23:32:27Z"
            },
            {
              "originalPosition": 506,
              "body": "```suggestion\r\n- The TokenRequest contains a supported token_type\r\n- The TokenRequest.issuer_key_id corresponds to a key ID of a Public Key owned by the issuer.\r\n- The TokenRequest.blinded_msg is of the correct size\r\n```",
              "createdAt": "2021-12-15T23:30:40Z",
              "updatedAt": "2021-12-15T23:32:27Z"
            },
            {
              "originalPosition": 705,
              "body": "```suggestion\r\nblinded_msg, blind_inv = rsabssa_blind(Issuer Key, message)\r\n```",
              "createdAt": "2021-12-15T23:31:09Z",
              "updatedAt": "2021-12-15T23:32:27Z"
            },
            {
              "originalPosition": 720,
              "body": "```suggestion\r\n   uint8_t issuer_key_id;\r\n```",
              "createdAt": "2021-12-15T23:31:22Z",
              "updatedAt": "2021-12-15T23:32:27Z"
            },
            {
              "originalPosition": 733,
              "body": "```suggestion\r\n- \"issuer_key_id\" is the least significant byte of the `key_id`.\r\n```",
              "createdAt": "2021-12-15T23:31:29Z",
              "updatedAt": "2021-12-15T23:32:27Z"
            },
            {
              "originalPosition": 768,
              "body": "```suggestion\r\n- The TokenRequest contains a supported token_type.\r\n- The TokenRequest.issuer_key_id corresponds to a key ID of a Public Key owned by the issuer.\r\n- The TokenRequest.blinded_msg is of the correct size.\r\n```",
              "createdAt": "2021-12-15T23:32:06Z",
              "updatedAt": "2021-12-15T23:32:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84yPxou",
          "commit": {
            "abbreviatedOid": "375a304"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-03T19:46:45Z",
          "updatedAt": "2022-01-03T19:46:46Z",
          "comments": [
            {
              "originalPosition": 664,
              "body": "This reference is wrong, since it's pointing to the VOPRF text.",
              "createdAt": "2022-01-03T19:46:46Z",
              "updatedAt": "2022-01-03T19:46:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84yQLEm",
          "commit": {
            "abbreviatedOid": "375a304"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-03T23:13:40Z",
          "updatedAt": "2022-01-03T23:13:40Z",
          "comments": [
            {
              "originalPosition": 695,
              "body": "@chris-wood should this be the following?\r\n\r\n```suggestion\r\nblinded_msg, blind_inv = rsabssa_blind(pkI, token_input)\r\n```",
              "createdAt": "2022-01-03T23:13:40Z",
              "updatedAt": "2022-01-03T23:13:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84yQLTp",
          "commit": {
            "abbreviatedOid": "375a304"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-03T23:16:26Z",
          "updatedAt": "2022-01-03T23:16:27Z",
          "comments": [
            {
              "originalPosition": 664,
              "body": "```suggestion\r\n  described in {{public-issuer-configuration}}.\r\n```",
              "createdAt": "2022-01-03T23:16:26Z",
              "updatedAt": "2022-01-03T23:16:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84yQLdh",
          "commit": {
            "abbreviatedOid": "4bfd0b6"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-03T23:18:13Z",
          "updatedAt": "2022-01-03T23:18:14Z",
          "comments": [
            {
              "originalPosition": 664,
              "body": "Fixed \ud83d\udc4d ",
              "createdAt": "2022-01-03T23:18:13Z",
              "updatedAt": "2022-01-03T23:18:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84zqh-d",
          "commit": {
            "abbreviatedOid": "4bfd0b6"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T23:11:19Z",
          "updatedAt": "2022-01-28T23:12:46Z",
          "comments": [
            {
              "originalPosition": 431,
              "body": "```suggestion\r\n   uint8_t token_key_id;\r\n```",
              "createdAt": "2022-01-28T23:11:20Z",
              "updatedAt": "2022-01-28T23:12:46Z"
            },
            {
              "originalPosition": 453,
              "body": "```suggestion\r\n- \"token_key_id\" is the least significant byte of the `key_id`.\r\n```",
              "createdAt": "2022-01-28T23:11:38Z",
              "updatedAt": "2022-01-28T23:12:47Z"
            },
            {
              "originalPosition": 495,
              "body": "```suggestion\r\n- The TokenRequest.token_key_id corresponds to a key ID of a Public Key owned by the issuer.\r\n```",
              "createdAt": "2022-01-28T23:11:53Z",
              "updatedAt": "2022-01-28T23:12:47Z"
            },
            {
              "originalPosition": 710,
              "body": "```suggestion\r\n   uint8_t token_key_id;\r\n```",
              "createdAt": "2022-01-28T23:12:11Z",
              "updatedAt": "2022-01-28T23:12:47Z"
            },
            {
              "originalPosition": 756,
              "body": "```suggestion\r\n- The TokenRequest.token_key_id corresponds to a key ID of a Public Key owned by the issuer.\r\n```",
              "createdAt": "2022-01-28T23:12:41Z",
              "updatedAt": "2022-01-28T23:12:47Z"
            },
            {
              "originalPosition": 723,
              "body": "```suggestion\r\n- \"token_key_id\" is the least significant byte of the `key_id`.\r\n```",
              "createdAt": "2022-01-28T23:12:42Z",
              "updatedAt": "2022-01-28T23:12:47Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84zqi_p",
          "commit": {
            "abbreviatedOid": "4ff79ca"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-01-28T23:20:59Z",
          "updatedAt": "2022-01-28T23:20:59Z",
          "comments": [
            {
              "originalPosition": 625,
              "body": "```suggestion\r\nkey_id = SHA256(0x0001 || SerializeElement(pkI))\r\n```",
              "createdAt": "2022-01-28T23:20:59Z",
              "updatedAt": "2022-01-28T23:20:59Z"
            }
          ]
        }
      ]
    },
    {
      "number": 88,
      "id": "PR_kwDODeTEy84v-iDg",
      "title": "Clarify large issuer quantity case",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/88",
      "state": "MERGED",
      "author": "smhendrickson",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-12-16T23:50:56Z",
      "updatedAt": "2021-12-17T13:20:02Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "caw/arch-refactor",
      "baseRefOid": "fba055ff97aab05d36849d5a1fee5bd50183a47d",
      "headRepository": "smhendrickson/base-drafts",
      "headRefName": "patch-1",
      "headRefOid": "a788a5d9df70926bb3423a92534749f9ba1766e5",
      "closedAt": "2021-12-17T13:20:02Z",
      "mergedAt": "2021-12-17T13:20:02Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b39ceb8ac02abba737b1bb17737a46a6c632f768"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy84xyHtp",
          "commit": {
            "abbreviatedOid": "61806bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-12-17T13:19:41Z",
          "updatedAt": "2021-12-17T13:19:41Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "```suggestion\r\nare a large number of Issuers and Origins accept all of them segregation \r\n```",
              "createdAt": "2021-12-17T13:19:41Z",
              "updatedAt": "2021-12-17T13:19:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84xyHvu",
          "commit": {
            "abbreviatedOid": "61806bc"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-12-17T13:19:50Z",
          "updatedAt": "2021-12-17T13:19:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 91,
      "id": "PR_kwDODeTEy84x3mw7",
      "title": "Align POPRF issuance with the latest VOPRF draft",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/91",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "draft-irtf-cfrg-voprf-09 went out today, and this just aligns the basic issuance protocol on top of those changes. \r\n\r\ncc @armfazh ",
      "createdAt": "2022-01-31T23:10:56Z",
      "updatedAt": "2022-01-31T23:33:38Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "80dac5d600b7ba250d5b3f30b75a560df59ee31a",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/align-poprf",
      "headRefOid": "9db25e1d3eeaf49ac52c9d68d775215496ed8360",
      "closedAt": "2022-01-31T23:33:38Z",
      "mergedAt": "2022-01-31T23:33:38Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a3f9004e932831a6284723fa74209e260c6500be"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy84zxKb5",
          "commit": {
            "abbreviatedOid": "25792e3"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-01-31T23:17:12Z",
          "updatedAt": "2022-01-31T23:19:14Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "```suggestion\r\nThe Client first creates a context as follows:\r\n```",
              "createdAt": "2022-01-31T23:17:12Z",
              "updatedAt": "2022-01-31T23:19:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 92,
      "id": "PR_kwDODeTEy84x62Vm",
      "title": "Address correlation attacks",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/92",
      "state": "CLOSED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Drafty draft that addresses #90. I tried to generalize the problem and focus on correlation via either the _source_ for an event, like the client IP address or whatever, and the _context_ of an event, like the timestamp at which it occurs or the origin associated with the event. It is not a tremendous problem if two things are correlated via context so long as the clients are not linkable. (This is the argument with things like ODoH, where we can't link any two requests to the same client, but we can link two requests as being related.) What's most important here, I think, is source correlation, and clients can control this by working _through_ an attester or some other proxy.\r\n\r\nWhat do folks think?\r\n\r\nStarting as a draft while we work on the presentation.\r\n\r\nCloses #90.",
      "createdAt": "2022-02-01T17:33:56Z",
      "updatedAt": "2022-03-02T17:11:03Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "a3f9004e932831a6284723fa74209e260c6500be",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/correlation",
      "headRefOid": "817ee205851e084604d336fdbd45ccacc24bd47e",
      "closedAt": "2022-03-02T17:11:03Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@tfpauly @dvorak42 @alxdavids ready for review now. @janaiyengar, please have a look, too!",
          "createdAt": "2022-02-02T19:28:08Z",
          "updatedAt": "2022-02-02T19:28:08Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing in favor of #100.",
          "createdAt": "2022-03-02T17:11:03Z",
          "updatedAt": "2022-03-02T17:11:03Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy84z1Dd8",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T17:43:26Z",
          "updatedAt": "2022-02-01T17:55:34Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I don't think this is in scope unless we are also going to discuss architectures and protocols for (safe?) client-to-client token sharing.",
              "createdAt": "2022-02-01T17:43:26Z",
              "updatedAt": "2022-02-01T17:55:34Z"
            },
            {
              "originalPosition": 50,
              "body": "If the issuer doesn't know the client's identity, then it seems to me that the client doesn't need to use blind signatures at all. If this use case is in-scope, I think it would be clearer to offer a very simple Issuance Algorithm that is well-suited for it (e.g. plain ECDSA).",
              "createdAt": "2022-02-01T17:50:22Z",
              "updatedAt": "2022-02-01T17:55:34Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z1Mbz",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T18:02:53Z",
          "updatedAt": "2022-02-01T18:02:54Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "This is noting that clients _can_ be transferred.",
              "createdAt": "2022-02-01T18:02:53Z",
              "updatedAt": "2022-02-01T18:02:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z1Lnf",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T18:00:56Z",
          "updatedAt": "2022-02-01T18:03:16Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Maybe I'm mixing up terminology, but with per-origin tokens, the issuance context is still the mediator/issuer, while the redemption context is the origin you're getting tokens for?\r\n\r\nWhich means you can still have a malicious entity try linking your mediator-specific state with a particular redemption even with per-origin tokens?",
              "createdAt": "2022-02-01T18:00:57Z",
              "updatedAt": "2022-02-01T18:03:16Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z1Mo4",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T18:03:20Z",
          "updatedAt": "2022-02-01T18:03:20Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Sure -- this is why we have the registry of issuance protocols. =)",
              "createdAt": "2022-02-01T18:03:20Z",
              "updatedAt": "2022-02-01T18:03:20Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z1Owz",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T18:08:09Z",
          "updatedAt": "2022-02-01T18:08:09Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "> Maybe I'm mixing up terminology, but with per-origin tokens, the issuance context is still the mediator/issuer, while the redemption context is the origin you're getting tokens for?\r\n\r\nIt depends on the issuance protocol. For per-origin rate-limited tokens, for example, the issuer learns the origin, so the issuance context would include the origin. \r\n\r\nI didn't get into whether or not the attester and issuer are lumped together here.\r\n\r\n> Which means you can still have a malicious entity try linking your mediator-specific state with a particular redemption even with per-origin tokens?\r\n\r\nIf I understand correctly, this is true. Attester state, as in the rate limited case, could possibly be used for linking. We could somehow note that?",
              "createdAt": "2022-02-01T18:08:09Z",
              "updatedAt": "2022-02-01T18:08:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z1q2q",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T19:20:14Z",
          "updatedAt": "2022-02-01T19:20:17Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Maybe just a quick sentence about it, and then expand on it once we discuss the rate limited case where the attester has actual state that could be linked? Though maybe waiting until then is okay.",
              "createdAt": "2022-02-01T19:20:14Z",
              "updatedAt": "2022-02-01T19:20:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z2NFB",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T21:27:50Z",
          "updatedAt": "2022-02-01T21:49:39Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I don't think we can hang our privacy safety claim on a client behavior that is never otherwise standardized, recommended, or even discussed.  Also, this kind of sharing is unsafe in general, and seems unlikely to occur in practice without substantial changes to Privacy Pass.\r\n\r\nIf you want to open this can of worms, I think you have to open it all the way.",
              "createdAt": "2022-02-01T21:27:50Z",
              "updatedAt": "2022-02-01T21:49:39Z"
            },
            {
              "originalPosition": 50,
              "body": "If this architecture  and protocol are intended to cover that use case, then we have an interesting charter discussion, because the charter says: \"An Issuer cannot link a redeemed token to one of N previously created tokens\r\nusing the same key\".\r\n\r\nIf we are covering use cases that have very small effective `N`, even `N=1`, I think that needs to be made very clear to the working group.  Defining a non-blinded token algorithm now could be a good way to focus that discussion.",
              "createdAt": "2022-02-01T21:35:49Z",
              "updatedAt": "2022-02-01T21:49:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z2V3s",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T22:08:33Z",
          "updatedAt": "2022-02-01T22:08:33Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I think there's a misunderstanding here. Per the charter, a goal of this protocol is to \"specify an extensible protocol for creating and redeeming anonymous and transferrable tokens.\" The key word is _transferrable_. This paragraph is simply acknowledging that tokens _can_ in fact be transferred amongst clients -- by design! It is by no means encouraging this behavior. The can of worms is already open.",
              "createdAt": "2022-02-01T22:08:33Z",
              "updatedAt": "2022-02-01T22:08:33Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z2WGq",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T22:09:39Z",
          "updatedAt": "2022-02-01T22:09:39Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "> If we are covering use cases that have very small effective N, even N=1, I think that needs to be made very clear to the working group. Defining a non-blinded token algorithm now could be a good way to focus that discussion.\r\n\r\nI disagree. The value of N is _entirely_ deployment specific. It cannot be addressed in the protocol, without an incredibly different design. ",
              "createdAt": "2022-02-01T22:09:39Z",
              "updatedAt": "2022-02-01T22:09:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z2WM_",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-01T22:10:10Z",
          "updatedAt": "2022-02-01T22:10:10Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "A sentence would be good, yeah, noting that issuance protocol state can be used for linking. ",
              "createdAt": "2022-02-01T22:10:10Z",
              "updatedAt": "2022-02-01T22:10:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z6e7G",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T18:43:30Z",
          "updatedAt": "2022-02-02T18:49:59Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "```suggestion\r\nis that it needs to provide unconditional input secrecy. This means that an issuance event\r\n```",
              "createdAt": "2022-02-02T18:43:30Z",
              "updatedAt": "2022-02-02T18:49:59Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\nand its corresponding redemption event are unlinkable using the contents of\r\n```",
              "createdAt": "2022-02-02T18:44:09Z",
              "updatedAt": "2022-02-02T18:49:59Z"
            },
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nbar.example are related. In contrast, per-origin token contexts are limited a single origin,\r\n```",
              "createdAt": "2022-02-02T18:45:04Z",
              "updatedAt": "2022-02-02T18:49:59Z"
            },
            {
              "originalPosition": 46,
              "body": "How realistic is the handing-off tokens case? If it's not very common, it doesn't seem like a strong mitigation.",
              "createdAt": "2022-02-02T18:46:31Z",
              "updatedAt": "2022-02-02T18:49:59Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z6hNE",
          "commit": {
            "abbreviatedOid": "465c3c8"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T18:51:23Z",
          "updatedAt": "2022-02-02T18:51:23Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "This isn't meant to suggest it as a mitigation. It's merely meant to say that an origin cannot guarantee that the same client which went through issuance is the same client which redeemed a token, because they're transferrable. (What part of the text suggests this is a mitigation?)",
              "createdAt": "2022-02-02T18:51:23Z",
              "updatedAt": "2022-02-02T19:02:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z6iNA",
          "commit": {
            "abbreviatedOid": "3af875b"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T18:54:11Z",
          "updatedAt": "2022-02-02T18:54:11Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "It doesn't directly say it's a mitigation, I was just inferring that.",
              "createdAt": "2022-02-02T18:54:11Z",
              "updatedAt": "2022-02-02T18:54:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z6i0W",
          "commit": {
            "abbreviatedOid": "3af875b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T18:55:54Z",
          "updatedAt": "2022-02-02T18:55:54Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Ah, okay, is there any way we could clarify? (@bemasc zeroed in on this as well, so surely the text could be improved.)",
              "createdAt": "2022-02-02T18:55:54Z",
              "updatedAt": "2022-02-02T18:55:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy84z6otL",
          "commit": {
            "abbreviatedOid": "3af875b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-02T19:27:26Z",
          "updatedAt": "2022-02-02T19:27:26Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "@dvorak42 added state example!",
              "createdAt": "2022-02-02T19:27:26Z",
              "updatedAt": "2022-02-02T19:27:26Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840AX-C",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "janaiyengar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T23:07:14Z",
          "updatedAt": "2022-02-03T23:07:14Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Do we need this paragraph?",
              "createdAt": "2022-02-03T23:07:14Z",
              "updatedAt": "2022-02-03T23:07:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840AYA7",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "janaiyengar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "One comment, else looks good!",
          "createdAt": "2022-02-03T23:07:35Z",
          "updatedAt": "2022-02-03T23:07:35Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy840AYL2",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "janaiyengar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T23:08:41Z",
          "updatedAt": "2022-02-03T23:08:42Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I had the same read as tfpauly -- that this suggests a mitigation, but you're right that it doesn't. If it's not a common use case, why use this example? And I'm then wondering if removing it entirely removes anything importnat -- it seems to me that it doesnt.",
              "createdAt": "2022-02-03T23:08:41Z",
              "updatedAt": "2022-02-03T23:08:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840AYoI",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-03T23:11:27Z",
          "updatedAt": "2022-02-03T23:11:27Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I think this paragraph is important because it notes that linking issuance and redemption together may not constitute an actual attack. Token transfer is a fundamental property of this protocol. This text acknowledges that property.",
              "createdAt": "2022-02-03T23:11:27Z",
              "updatedAt": "2022-02-03T23:11:27Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840AY7A",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "janaiyengar",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "ok, sounds good -- thanks for working on this, @chris-wood !",
          "createdAt": "2022-02-03T23:13:20Z",
          "updatedAt": "2022-02-03T23:13:20Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy840DMII",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-04T15:42:01Z",
          "updatedAt": "2022-02-04T15:42:01Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy840D6cg",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-04T18:33:49Z",
          "updatedAt": "2022-02-04T18:33:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy840D_sf",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-04T18:54:08Z",
          "updatedAt": "2022-02-04T18:54:09Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I still don't think this text is helpful.  Most digital identification systems have this transferability property.  Passwords, private keys, even hardware tokens are all transferable between people.  Transferability is trivial unless there's a reason to expect it will be unusually common.\r\n\r\nThis text seems to be arguing against the strawman position that correlation _always_ harms privacy.  In general, I don't think that there is any technical action that _always_ harms privacy.  The important question is whether there is some real use case where an otherwise-dangerous thing becomes safe.  I would prefer to see the focus there.",
              "createdAt": "2022-02-04T18:54:08Z",
              "updatedAt": "2022-02-04T18:54:09Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840EKJI",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-04T19:41:21Z",
          "updatedAt": "2022-02-04T19:41:21Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> I still don't think this text is helpful. Most digital identification systems have this transferability property. Passwords, private keys, even hardware tokens are all transferable between people. Transferability is trivial unless there's a reason to expect it will be unusually common.\r\n> \r\n> This text seems to be arguing against the strawman position that correlation always harms privacy. In general, I don't think that there is any technical action that always harms privacy. The important question is whether there is some real use case where an otherwise-dangerous thing becomes safe. I would prefer to see the focus there.\r\n\r\nI'm trying to understand you but am failing to do so. Surely there are technical actions that always harm privacy. For example, never using HTTPS is harmful, revealing your IP address and other fingerprinting information to an origin is harmful, allowing third-party cookies to track you is harmful, etc. \r\n\r\nIs your objection to the phrasing \"privacy violation\"? If not, what is it?",
              "createdAt": "2022-02-04T19:41:21Z",
              "updatedAt": "2022-02-04T19:41:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840EPtC",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-04T20:05:21Z",
          "updatedAt": "2022-02-04T20:05:21Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "In an attempt to find a compromise, here's a proposed rephrasing of the text:\r\n\r\n~~~\r\nContext correlation between two events may not constitute a privacy violation if \r\nthere is no source correlation between those two events. For example, if issuance\r\nfor a visit to foo.example was correlated to redemption of a visit to bar.example,\r\nyet the source for these two events was uncorrelated, then one only learns that these\r\ntwo events are related and might be associated with the same source (Client). In\r\ncontrast, if the source of these two events were correlated, then one learns that \r\nthe two visits correspond to the same source (Client), thereby leaking browsing history.\r\n~~~\r\n\r\n@tfpauly, @janaiyengar, @bemasc, is this an improvement?",
              "createdAt": "2022-02-04T20:05:21Z",
              "updatedAt": "2022-02-04T20:05:21Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840ERI5",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-04T20:12:42Z",
          "updatedAt": "2022-02-04T20:12:42Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "One way to frame the problem is that this text describes a \"scenario\" involving multiple clients (an \"acquiring client\" and \"redeeming client\"), but this scenario is not contemplated in Section 3, which defines the scope of this design as involving only 4 communicating parties.  We shouldn't be performing security analysis based on scenarios that aren't in scope.\r\n\r\nIt seems like this section inverts the ordinary logic of security analysis.  Instead of asking \"is there any strange situation where this could be dangerous?\", it asks \"is there any strange situation where this could be safe?\".\r\n\r\n> For example, never using HTTPS is harmful\r\n\r\nYes, and this text is like \"Depending on the content used, insecure HTTPS may not be a privacy violation.  In particular, because the HTTP payload may already be encrypted using HPKE, ...\".  This is true, but it's not helpful unless that is a relevant, reasonably common use case.",
              "createdAt": "2022-02-04T20:12:42Z",
              "updatedAt": "2022-02-04T20:12:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840ERo5",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-04T20:15:14Z",
          "updatedAt": "2022-02-04T20:15:15Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "> One way to frame the problem is that this text describes a \"scenario\" involving multiple clients (an \"acquiring client\" and \"redeeming client\"), but this scenario is not contemplated in Section 3, which defines the scope of this design as involving only 4 communicating parties. We shouldn't be performing security analysis based on scenarios that aren't in scope.\r\n\r\nI very strongly disagree with this statement! The protocol is defined in terms of 4 parties, but security and privacy need to account for multiple instances of each. This is fairly common practice.",
              "createdAt": "2022-02-04T20:15:14Z",
              "updatedAt": "2022-02-04T20:15:15Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840ESC0",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "bemasc",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-04T20:17:18Z",
          "updatedAt": "2022-02-04T20:17:18Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Yes, it cannot be addressed in the protocol, but it can be addressed in the architecture documentation, and already is, in section 6.  That section's analysis is invalidated by these changes, and needs to be updated.",
              "createdAt": "2022-02-04T20:17:18Z",
              "updatedAt": "2022-02-04T20:17:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy840ESNw",
          "commit": {
            "abbreviatedOid": "817ee20"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-02-04T20:18:12Z",
          "updatedAt": "2022-02-04T20:18:12Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "~~Sure. Separate PR.~~\r\n\r\nActually, I take that back. I don't think this invalidates Section 6, as that section is already somewhat meaningless. I'm going to propose updating that section in a separate change.",
              "createdAt": "2022-02-04T20:18:12Z",
              "updatedAt": "2022-02-04T20:21:58Z"
            }
          ]
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDODeTEy84yGyI8",
      "title": "Point to OPRF and blind RSA function definitions",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/94",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It's not obvious where to find these things!\r\n\r\ncc @armfazh ",
      "createdAt": "2022-02-04T21:49:49Z",
      "updatedAt": "2022-02-07T21:14:17Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "a3f9004e932831a6284723fa74209e260c6500be",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/function-pointers",
      "headRefOid": "e364bf0f8e6fefe81eae0c28d1506e320b725e99",
      "closedAt": "2022-02-07T21:14:17Z",
      "mergedAt": "2022-02-07T21:14:17Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "cd845fbac27f1bbddccaa9079856f6d7b530bfac"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy840KnIA",
          "commit": {
            "abbreviatedOid": "e364bf0"
          },
          "author": "tfpauly",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-02-07T20:13:48Z",
          "updatedAt": "2022-02-07T20:13:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 99,
      "id": "PR_kwDODeTEy84zvU7e",
      "title": "Add configuration parameters",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/99",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #96.\r\n\r\ncc @mnot, @tfpauly ",
      "createdAt": "2022-03-01T16:26:51Z",
      "updatedAt": "2022-03-03T23:39:44Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "cd845fbac27f1bbddccaa9079856f6d7b530bfac",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/configuration",
      "headRefOid": "4790e89b3e7c1fbd067783fcc9a09dc9f8655a5e",
      "closedAt": "2022-03-02T17:11:12Z",
      "mergedAt": "2022-03-02T17:11:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "9cb46ee740b9e88707935753951efa99150dc15d"
      },
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "This is fine, but why are you using a well-known location? It seems like it's just adding a RT so that people can avoid using a full URI for configuration. ",
          "createdAt": "2022-03-03T22:54:25Z",
          "updatedAt": "2022-03-03T22:54:25Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@mnot can you help us understand what would be the preferred alternative? At the end of the day, if I'm an origin or client and need to get this information from an issuer, and all I have is the issuer name, what am I left with?",
          "createdAt": "2022-03-03T22:56:48Z",
          "updatedAt": "2022-03-03T22:56:48Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "So that's the question -- what does the person using the service have to start with? \r\n\r\nE.g., if I know that the service I want to work with is \"cloudflare\", I still have to discover something more specific, even with the current `.well-known` approach -- I need a hostname (and possibly a port). It might be `cloudflare.com`, but it equally could be `api.cloudflare.com` or `privacypass-inititate.cloudflare.com`.\r\n\r\nSo I have to find it somewhere, probably in documentation. Given that I have to go through that process as a consumer of this API, what's the advantage of configuring with just a hostname, vs. a full URL -- allowing you to skip the .well-known location?\r\n\r\nSkipping the .well-known saves latency and also avoids some caching issues (i.e., how long can you trust the information in it for? How do you manage change?)\r\n\r\nThere are reasons that this would be the case -- e.g., if there's a lot more configuration information to convey (that hasn't made it into the spec yet), the indirection is actually desirable for operational purposes, or that the hostname _can_ be inferred / discovered automatically (e.g., with a DNS record for the registrable domain name). I'm not deep enough into this protocol to know whether any of this is the case.\r\n\r\n",
          "createdAt": "2022-03-03T23:09:19Z",
          "updatedAt": "2022-03-03T23:09:19Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "> E.g., if I know that the service I want to work with is \"cloudflare\", I still have to discover something more specific, even with the current .well-known approach -- I need a hostname (and possibly a port). It might be cloudflare.com, but it equally could be api.cloudflare.com or privacypass-inititate.cloudflare.com.\r\n\r\nI would expect a common practice to be that folks are configured with the full authority (`issuer.example` and the implied :443 port). And [following best practices](https://www.ietf.org/id/draft-ietf-httpbis-bcp56bis-15.html#name-discovering-an-applications), they could then use to this discover additional information using a registered .well-known. \r\n\r\nBut, to your point, if they're configured this way, it's probably reasonable to require them to simply be configured with the full URL used to obtain the configuration dictionary. That is, instead of configuring them `issuer.example`, configure them with `https://issuer.example/my-special-configuraiton-url/`. \r\n\r\nI'm not sure we have enough experience yet to know which of these would be preferred. It's probably worth splitting this off into a separate issue to track as things progress. @tfpauly, thoughts?",
          "createdAt": "2022-03-03T23:39:44Z",
          "updatedAt": "2022-03-03T23:39:44Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy841cBNK",
          "commit": {
            "abbreviatedOid": "8bef0cb"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-01T16:28:19Z",
          "updatedAt": "2022-03-01T16:28:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 100,
      "id": "PR_kwDODeTEy84z19ca",
      "title": "Add deployment models and considerations",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/100",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #90.\r\n\r\ncc @janaiyengar, @tfpauly, @smhendrickson, @dvorak42 ",
      "createdAt": "2022-03-02T17:10:30Z",
      "updatedAt": "2022-03-05T16:50:03Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "cd845fbac27f1bbddccaa9079856f6d7b530bfac",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/deployment-and-privacy",
      "headRefOid": "984620cf4b116aa7fdd830441259d39a29542257",
      "closedAt": "2022-03-05T16:49:13Z",
      "mergedAt": "2022-03-05T16:49:12Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "4ab8b9dcc090f7114541c9da81866ff4db3db774"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy841hW3p",
          "commit": {
            "abbreviatedOid": "4acf0e3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-02T17:47:35Z",
          "updatedAt": "2022-03-02T17:47:42Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "It may be good to point out that this model is less useful if there's only one origin for the issuer \u2014 since then the attester knows exactly what the origin is. In that case, some token types aren't advisable.",
              "createdAt": "2022-03-02T17:47:35Z",
              "updatedAt": "2022-03-02T17:47:42Z"
            },
            {
              "originalPosition": 86,
              "body": "Should we mention at all how the client knows which entities are separate? If that's out of scope, can we say so or make a reference?",
              "createdAt": "2022-03-02T17:47:38Z",
              "updatedAt": "2022-03-02T17:47:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy841hZc5",
          "commit": {
            "abbreviatedOid": "4acf0e3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T17:52:35Z",
          "updatedAt": "2022-03-02T17:52:35Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Hmm, I don't think clients can know they're separate or not colluding. So we could probably just say, \"Mechanisms for enforcing non-collusion are out of scope for this architecture.\"?",
              "createdAt": "2022-03-02T17:52:35Z",
              "updatedAt": "2022-03-02T17:52:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy841haKk",
          "commit": {
            "abbreviatedOid": "4acf0e3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T17:53:55Z",
          "updatedAt": "2022-03-02T17:53:55Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "Indeed, per-origin tokens challenged by a single origin seem useless, though I'm not sure we need to explicitly call it out. Curious to hear what others think!",
              "createdAt": "2022-03-02T17:53:55Z",
              "updatedAt": "2022-03-02T17:53:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy841hbnK",
          "commit": {
            "abbreviatedOid": "4acf0e3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T17:56:29Z",
          "updatedAt": "2022-03-02T17:56:29Z",
          "comments": [
            {
              "originalPosition": 86,
              "body": "Yup, that would be good to add.",
              "createdAt": "2022-03-02T17:56:29Z",
              "updatedAt": "2022-03-02T17:56:29Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy841hcMa",
          "commit": {
            "abbreviatedOid": "4acf0e3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T17:57:23Z",
          "updatedAt": "2022-03-02T17:57:23Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "I think it's important to call out, since it reduces the applicability of this deployment model. If my origin is small (only one real origin), then I should know that this probably isn't the right choice for me.",
              "createdAt": "2022-03-02T17:57:23Z",
              "updatedAt": "2022-03-02T17:57:23Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy841hdwS",
          "commit": {
            "abbreviatedOid": "4acf0e3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-02T18:02:36Z",
          "updatedAt": "2022-03-02T18:02:36Z",
          "comments": [
            {
              "originalPosition": 207,
              "body": "I don't really agree, but also don't feel strongly, so I'll add it.",
              "createdAt": "2022-03-02T18:02:36Z",
              "updatedAt": "2022-03-02T18:02:36Z"
            }
          ]
        }
      ]
    },
    {
      "number": 101,
      "id": "PR_kwDODeTEy84z-aw5",
      "title": "Add test vectors for basic issuance",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/101",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #93. Generated from [this PR](https://github.com/cloudflare/pat-go/pull/5).\r\n\r\ncc @tfpauly, @armfazh, @claucece ",
      "createdAt": "2022-03-04T20:44:11Z",
      "updatedAt": "2022-03-07T15:27:09Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "8056406cb686fed8f509c864cac895c1a6076967",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/test-vectors",
      "headRefOid": "51336450d55e900ec71f18472eec472c53505bc7",
      "closedAt": "2022-03-07T15:27:08Z",
      "mergedAt": "2022-03-07T15:27:08Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "5f7ca4bd744afeb2f39d8d377a87b0498a153acd"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy841r6k8",
          "commit": {
            "abbreviatedOid": "156b494"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-04T20:47:02Z",
          "updatedAt": "2022-03-04T20:47:03Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nThis is encoded and transmitted to the client in the following TokenResponse structure:\r\n```\r\n```suggestion\r\nThis is encoded an transmitted to the client in the following TokenResponse structure:\r\n```",
              "createdAt": "2022-03-04T20:47:02Z",
              "updatedAt": "2022-03-04T20:47:03Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy841r7El",
          "commit": {
            "abbreviatedOid": "5133645"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-04T20:49:42Z",
          "updatedAt": "2022-03-04T20:49:42Z",
          "comments": []
        }
      ]
    },
    {
      "number": 105,
      "id": "PR_kwDODeTEy840U1i4",
      "title": "Rename redemption_nonce to redemption_context",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/105",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #103 ",
      "createdAt": "2022-03-11T22:35:54Z",
      "updatedAt": "2022-03-14T18:08:37Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "5f7ca4bd744afeb2f39d8d377a87b0498a153acd",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "tfp/redemption_context",
      "headRefOid": "f5157d12f18ea33e92ea4ead16b74b2fad42d071",
      "closedAt": "2022-03-14T18:08:37Z",
      "mergedAt": "2022-03-14T18:08:37Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "079d020a283ff89e2ede31084574560b7faf245f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy842HQnS",
          "commit": {
            "abbreviatedOid": "09cd643"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-11T23:01:46Z",
          "updatedAt": "2022-03-11T23:03:35Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "```suggestion\r\nissuer and issuance protocol, and may be additionally bound to a specific context or origin name.\r\n```",
              "createdAt": "2022-03-11T23:01:47Z",
              "updatedAt": "2022-03-11T23:03:35Z"
            },
            {
              "originalPosition": 115,
              "body": "```suggestion\r\nto reusing tokens that were fetched for other contexts. When present, this value\r\n```",
              "createdAt": "2022-03-11T23:02:04Z",
              "updatedAt": "2022-03-11T23:03:35Z"
            },
            {
              "originalPosition": 116,
              "body": "```suggestion\r\nis a 32-byte context generated by the origin. This value can be a unique\r\n```\r\n\r\nIt doesn't need to be \"fresh\" since one can compute it deterministically.",
              "createdAt": "2022-03-11T23:02:30Z",
              "updatedAt": "2022-03-11T23:03:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy842LUnk",
          "commit": {
            "abbreviatedOid": "f5157d1"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-14T15:04:30Z",
          "updatedAt": "2022-03-14T15:04:30Z",
          "comments": []
        }
      ]
    },
    {
      "number": 106,
      "id": "PR_kwDODeTEy840d7vV",
      "title": "Explain length field in TokenChallenge",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/106",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "auth-scheme"
      ],
      "body": "For anyone unfamiliar with TLS struct notation, spell out the length fields in the text.",
      "createdAt": "2022-03-15T14:40:07Z",
      "updatedAt": "2022-03-15T15:19:56Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "079d020a283ff89e2ede31084574560b7faf245f",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "tfpauly-patch-1",
      "headRefOid": "d266e192ca4639808714f3a3617039627312dcb8",
      "closedAt": "2022-03-15T15:19:56Z",
      "mergedAt": "2022-03-15T15:19:56Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "53aad1254dfd127e8200824423b07d8ecfd1df7f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy842QmaW",
          "commit": {
            "abbreviatedOid": "d161f9c"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-15T14:40:57Z",
          "updatedAt": "2022-03-15T14:40:58Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "```suggestion\r\nnon-origin-specific token can be redeemed.\r\n```",
              "createdAt": "2022-03-15T14:40:57Z",
              "updatedAt": "2022-03-15T14:40:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy842Qn5b",
          "commit": {
            "abbreviatedOid": "d266e19"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-15T14:44:34Z",
          "updatedAt": "2022-03-15T14:44:34Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy842Q2V6",
          "commit": {
            "abbreviatedOid": "d266e19"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-15T15:19:51Z",
          "updatedAt": "2022-03-15T15:19:51Z",
          "comments": []
        }
      ]
    },
    {
      "number": 107,
      "id": "PR_kwDODeTEy840eCYr",
      "title": "Explain when to flush context-bound tokens",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/107",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "auth-scheme"
      ],
      "body": "Closes #102",
      "createdAt": "2022-03-15T15:03:54Z",
      "updatedAt": "2022-04-18T11:26:16Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "079d020a283ff89e2ede31084574560b7faf245f",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "tfpauly-patch-2",
      "headRefOid": "0124db3aaeb98fcac1682ceda405fa598ac8114f",
      "closedAt": "2022-03-15T20:15:16Z",
      "mergedAt": "2022-03-15T20:15:16Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "8e2999c4b16b23ce3903a1b4ac7e882de6f338fa"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy842QwvW",
          "commit": {
            "abbreviatedOid": "35f1029"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-15T15:05:48Z",
          "updatedAt": "2022-03-15T15:05:50Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "```suggestion\r\nUsing these tokens in a context that otherwise would not be linkable to the\r\noriginal context could allow the Origin to recognize a Client.\r\n\r\n```",
              "createdAt": "2022-03-15T15:05:48Z",
              "updatedAt": "2022-03-15T15:05:50Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy842RHyM",
          "commit": {
            "abbreviatedOid": "0124db3"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-15T16:03:27Z",
          "updatedAt": "2022-03-15T16:03:27Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy844SQ_h",
          "commit": {
            "abbreviatedOid": "0124db3"
          },
          "author": "Viosuna",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-18T11:26:16Z",
          "updatedAt": "2022-04-18T11:26:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 109,
      "id": "PR_kwDODeTEy841Lk-L",
      "title": "Support multiple origin names",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/109",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "auth-scheme"
      ],
      "body": "Closes #108 ",
      "createdAt": "2022-03-28T19:58:09Z",
      "updatedAt": "2022-03-30T21:33:59Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "8e2999c4b16b23ce3903a1b4ac7e882de6f338fa",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "tfp/multiple-origin-names",
      "headRefOid": "976e492ffa2a4c0f76fda9c0dc219a3e338247d2",
      "closedAt": "2022-03-30T21:33:59Z",
      "mergedAt": "2022-03-30T21:33:59Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "247cf93f20be88029fa733cffe773300b40da9fa"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@dvorak42 please have a look!",
          "createdAt": "2022-03-30T16:30:36Z",
          "updatedAt": "2022-03-30T16:30:36Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy843Nqbe",
          "commit": {
            "abbreviatedOid": "8b3898d"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2022-03-30T15:34:05Z",
          "updatedAt": "2022-03-30T15:36:42Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "```suggestion\r\norigin_info field, the client MUST validate that the name of the origin\r\nthat issued the authentication challenge is included in the list of origin\r\nnames. Clients MAY have further restrictions and requirements around\r\nvalidating when a challenge is considered acceptable or valid. For example,\r\nclients can choose to reject challenges that list origin names for which \r\ncurrent connection is not authoritative (according to the TLS certificate).\r\n```\r\n\r\nI don't think a SHOULD is strong enough here. If it's not required, then a client can skip this step, and an origin could abuse it to probe the client for tokens issued to other origins of its choosing. For example:\r\n\r\n- Client visits A.com, gets two token challenges that specify A.com in origin_info, and gets two tokens.\r\n- Client visits B.com, which challenges the client for an A.com token, and it happily redeems the A.com token.\r\n\r\nThis is not the same as a cross-origin token, since no origin name is specified there.",
              "createdAt": "2022-03-30T15:34:05Z",
              "updatedAt": "2022-03-30T15:36:42Z"
            },
            {
              "originalPosition": 57,
              "body": "Also, in moving to a MUST, we should add text to the security considerations which explain why this effectively means origins must \"cross sign\" each other (by using the same origin_info) in order for tokens to be spent across origins.",
              "createdAt": "2022-03-30T15:36:39Z",
              "updatedAt": "2022-03-30T15:36:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy843N9pk",
          "commit": {
            "abbreviatedOid": "8b3898d"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-03-30T16:28:27Z",
          "updatedAt": "2022-03-30T16:28:28Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "@chris-wood added text to security considerations, please check",
              "createdAt": "2022-03-30T16:28:28Z",
              "updatedAt": "2022-03-30T16:28:28Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy843N-CF",
          "commit": {
            "abbreviatedOid": "976e492"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "\ud83c\udf89 perfect!",
          "createdAt": "2022-03-30T16:29:38Z",
          "updatedAt": "2022-03-30T16:29:38Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy843O-hA",
          "commit": {
            "abbreviatedOid": "976e492"
          },
          "author": "dvorak42",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-30T20:18:29Z",
          "updatedAt": "2022-03-30T20:18:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 110,
      "id": "PR_kwDODeTEy841Uv_Z",
      "title": "Include examples for context construction",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/110",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Based on examples from IETF 113. ",
      "createdAt": "2022-03-30T16:03:05Z",
      "updatedAt": "2022-03-30T16:30:22Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "8e2999c4b16b23ce3903a1b4ac7e882de6f338fa",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/context-examples",
      "headRefOid": "dcfa10960b646d7c3acb555f6b725cc2afb99cbc",
      "closedAt": "2022-03-30T16:30:22Z",
      "mergedAt": "2022-03-30T16:30:22Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "43938c89da2b087f6c60d1ee5e282abd090d5972"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy843N965",
          "commit": {
            "abbreviatedOid": "43cca89"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-30T16:29:16Z",
          "updatedAt": "2022-03-30T16:29:39Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "```suggestion\r\n- Context bound to a given time window: Construct redemption context as\r\n```",
              "createdAt": "2022-03-30T16:29:17Z",
              "updatedAt": "2022-03-30T16:29:39Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n- Context bound to a client location: Construct redemption context as\r\n```",
              "createdAt": "2022-03-30T16:29:24Z",
              "updatedAt": "2022-03-30T16:29:39Z"
            },
            {
              "originalPosition": 35,
              "body": "```suggestion\r\n- Context bound to a given time window and location: Construct redemption\r\n```",
              "createdAt": "2022-03-30T16:29:34Z",
              "updatedAt": "2022-03-30T16:29:39Z"
            }
          ]
        }
      ]
    },
    {
      "number": 111,
      "id": "PR_kwDODeTEy841VaDc",
      "title": "Revert back to VOPRF for basic private issuance",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/111",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "protocol"
      ],
      "body": "Since metadata can be bound to tokens via TokenChallenge.redemption_context, and the origin is ultimately the one who determines what metadata is supported, there's no more real need for the _issuer_ to supply this metadata. So let's go with the simpler VOPRF protocol instead!\r\n\r\nTest vectors generated from the code here: https://github.com/cloudflare/pat-go/pull/7\r\n\r\ncc @armfazh, @claucece, @dvorak42 ",
      "createdAt": "2022-03-30T19:07:55Z",
      "updatedAt": "2022-04-05T13:15:50Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "43938c89da2b087f6c60d1ee5e282abd090d5972",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/back-to-voprf",
      "headRefOid": "07e2de33a12ca555e502a78678af64a94a7b036a",
      "closedAt": "2022-04-05T13:15:50Z",
      "mergedAt": "2022-04-05T13:15:50Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "a7c0bd43c91fd7bed940d4076d95a58b4f0b051a"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy843O0dL",
          "commit": {
            "abbreviatedOid": "07e2de3"
          },
          "author": "armfazh",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2022-03-30T19:37:54Z",
          "updatedAt": "2022-03-30T19:37:54Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy843O9g9",
          "commit": {
            "abbreviatedOid": "07e2de3"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-03-30T20:14:29Z",
          "updatedAt": "2022-03-30T20:14:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 112,
      "id": "PR_kwDODeTEy841hFXa",
      "title": "Move HTTP API to retired, align abbreviated names",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/112",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just some housekeeping",
      "createdAt": "2022-04-01T22:33:57Z",
      "updatedAt": "2022-04-01T23:15:20Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "247cf93f20be88029fa733cffe773300b40da9fa",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "tfp/cleanup",
      "headRefOid": "7130c7bd327a5da29948c3e2163eff9413b33d9b",
      "closedAt": "2022-04-01T23:15:20Z",
      "mergedAt": "2022-04-01T23:15:19Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "a5ad65f457fdf55cd133a9807454eb99ce671979"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy843ZrRL",
          "commit": {
            "abbreviatedOid": "7130c7b"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-01T23:03:54Z",
          "updatedAt": "2022-04-01T23:03:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 114,
      "id": "PR_kwDODeTEy841nGqF",
      "title": "Editorial: describe origin and client behavior more clearly",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/114",
      "state": "MERGED",
      "author": "tfpauly",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "tfpauly"
      ],
      "labels": [
        "auth-scheme"
      ],
      "body": "- Spell out origin steps more clearly\r\n- Split token caching into its own section\r\n\r\nI tried having an overall \"origin\" and \"client\" section, but it didn't flow as well.",
      "createdAt": "2022-04-04T20:14:30Z",
      "updatedAt": "2022-04-04T23:16:21Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "a5ad65f457fdf55cd133a9807454eb99ce671979",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "tfp/auth-scheme-editorial",
      "headRefOid": "b75176428cbddc711a5e3a2c68b745cf3f103908",
      "closedAt": "2022-04-04T23:16:21Z",
      "mergedAt": "2022-04-04T23:16:21Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "d6408e444427d01ced745cac17cf14f64701500f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy843fdYi",
          "commit": {
            "abbreviatedOid": "fc0a5ee"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-04T21:55:29Z",
          "updatedAt": "2022-04-04T22:00:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "```suggestion\r\n1. Select which issuer to use, and configure the issuer name and token-key to\r\n```\r\n\r\nFetch might make folks think of `fetch()`, whereas really this is a configuration task.",
              "createdAt": "2022-04-04T21:55:30Z",
              "updatedAt": "2022-04-04T22:00:25Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n1. Determine a redemption context construction to include in the TokenChallenge, as\r\n```\r\n\r\nSelect made me think that the context value was done once for everyone, but I think the intent here was to say \"figure out how you'll build redemption contexts\"?",
              "createdAt": "2022-04-04T21:56:22Z",
              "updatedAt": "2022-04-04T22:00:25Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nPreventing double spending on tokens requires the origin to keep state associated\r\nwith the redemption context. The size of this state varies based on the size of the\r\nredemption context. For example, double spend state for unique, per-request redemption\r\ncontexts does only needs to exist within the scope of the request connection or session.\r\nIn contrast, double spend state for empty redemption contexts must be stored and shared\r\nacross all requests until token-key expiration or rotation.\r\n```",
              "createdAt": "2022-04-04T21:59:43Z",
              "updatedAt": "2022-04-04T22:00:25Z"
            }
          ]
        }
      ]
    },
    {
      "number": 115,
      "id": "PR_kwDODeTEy841veUT",
      "title": "Remove issuance protocol requirements",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/115",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These are covered in the architecture.",
      "createdAt": "2022-04-06T15:16:02Z",
      "updatedAt": "2022-04-11T15:04:57Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "a7c0bd43c91fd7bed940d4076d95a58b4f0b051a",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/remove-issuance-requirements",
      "headRefOid": "98d70c5e68a4317e414096f14bf0ff13f3fd24c8",
      "closedAt": "2022-04-11T15:04:57Z",
      "mergedAt": "2022-04-11T15:04:57Z",
      "mergedBy": "tfpauly",
      "mergeCommit": {
        "oid": "e67114b94229ae902c89f55ac5b07406b21c3a0f"
      },
      "comments": [
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Bump @tfpauly @dvorak42!",
          "createdAt": "2022-04-11T14:32:20Z",
          "updatedAt": "2022-04-11T14:32:20Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy8436yO3",
          "commit": {
            "abbreviatedOid": "98d70c5"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-11T15:04:52Z",
          "updatedAt": "2022-04-11T15:04:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 116,
      "id": "PR_kwDODeTEy841vhAh",
      "title": "Add challenge and redemption test vectors",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/116",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We could omit the authenticator value and just focus on how Token is constructed based on TokenChallenge, but it seems reasonable to include the authenticator so folks can also test that they're computing the token key ID correctly.\r\n\r\nGenerated from [this change](https://github.com/cloudflare/pat-go/pull/8).",
      "createdAt": "2022-04-06T15:26:21Z",
      "updatedAt": "2022-04-11T14:32:01Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "a7c0bd43c91fd7bed940d4076d95a58b4f0b051a",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/auth-test-vectors",
      "headRefOid": "a53d1cbe5c3a2f9d06ad35fdc7f52ea5054ba28f",
      "closedAt": "2022-04-11T14:32:01Z",
      "mergedAt": "2022-04-11T14:32:01Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "830e16f2e57c2c3a545123c7decde438035129ab"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy843pvug",
          "commit": {
            "abbreviatedOid": "baf2043"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-06T15:29:18Z",
          "updatedAt": "2022-04-06T15:29:19Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Should we reference the protocol doc and specifically call out that these are for the RSA blind signature variant?",
              "createdAt": "2022-04-06T15:29:18Z",
              "updatedAt": "2022-04-06T15:29:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy843pwPR",
          "commit": {
            "abbreviatedOid": "baf2043"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-06T15:30:46Z",
          "updatedAt": "2022-04-06T15:30:46Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Done (but up above).",
              "createdAt": "2022-04-06T15:30:46Z",
              "updatedAt": "2022-04-06T15:30:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy843p4sa",
          "commit": {
            "abbreviatedOid": "a53d1cb"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-06T15:54:24Z",
          "updatedAt": "2022-04-06T15:54:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 122,
      "id": "PR_kwDODeTEy842oZl6",
      "title": "Pin down RSA details",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/122",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a breaking change since it updates the value of the code points. Starting as a draft until I'm able to produce matching test vectors. \r\n\r\nCloses #120.",
      "createdAt": "2022-04-22T15:14:47Z",
      "updatedAt": "2022-04-26T02:55:11Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "e67114b94229ae902c89f55ac5b07406b21c3a0f",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "caw/pin-rsa",
      "headRefOid": "2b08bb53aa75868fc33f69647b8ee4fc46145180",
      "closedAt": "2022-04-26T02:55:11Z",
      "mergedAt": "2022-04-26T02:55:11Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "e9e0efca4533c4d0ac7f8d7063a68f467b437d94"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Hm, I was thinking we'd just fully specify the types 1 and 2 right now, rather than trying to define a bunch of different combinations up front. Is there a benefit to listing all of the combinations out? Since for interop we want convergence on types, why not just have a very standard 1 and 2?",
          "createdAt": "2022-04-22T15:43:53Z",
          "updatedAt": "2022-04-22T15:43:53Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Convergence seems orthogonal to the values here, no? Implementations could just pick a common type, as we've done for ECH, HPKE, etc. It seems important to offer flexibility here for applications that might need it.",
          "createdAt": "2022-04-22T16:00:15Z",
          "updatedAt": "2022-04-22T16:00:15Z"
        },
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "For the common web cases, where we have websites that want to work with the wide range of clients, I'd prefer to see a very clear option of what to use by default \u2014 with one for privately verifiable, and one for publicly verifiable. If people have use cases that can't use these algorithms (like we've seen for IOT use cases, etc, for other protocols), I'd rather see those defined when there's a profile that has a driving use case. For example, we could end up defining a full matrix of different SHA lengths and key sizes (they're all 4096 right now for RSA, but we could have others) and that seems unnecessary.",
          "createdAt": "2022-04-22T16:13:57Z",
          "updatedAt": "2022-04-22T16:13:57Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": ">  If people have use cases that can't use these algorithms (like we've seen for IOT use cases, etc, for other protocols), I'd rather see those defined when there's a profile that has a driving use case.\r\n\r\nWell, we can RECOMMEND issuance protocols for common use cases, as we've done for ECH. ",
          "createdAt": "2022-04-22T16:16:24Z",
          "updatedAt": "2022-04-22T16:16:24Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Reverted type2 change!",
          "createdAt": "2022-04-22T16:33:54Z",
          "updatedAt": "2022-04-22T16:33:54Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "@tfpauly this is good to go now -- please have a look!",
          "createdAt": "2022-04-26T00:50:27Z",
          "updatedAt": "2022-04-26T00:50:27Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy844pOfD",
          "commit": {
            "abbreviatedOid": "20b6700"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-22T16:32:37Z",
          "updatedAt": "2022-04-22T16:32:38Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "I think you mean 0x0002 here \u2014 but I'd also like to keep 2 as the default blind RSA type",
              "createdAt": "2022-04-22T16:32:37Z",
              "updatedAt": "2022-04-22T16:32:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy844yIaS",
          "commit": {
            "abbreviatedOid": "39ee88a"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-04-26T02:35:14Z",
          "updatedAt": "2022-04-26T02:35:14Z",
          "comments": []
        }
      ]
    },
    {
      "number": 123,
      "id": "PR_kwDODeTEy842oaE7",
      "title": "Be more specific about the key ID",
      "url": "https://github.com/ietf-wg-privacypass/base-drafts/pull/123",
      "state": "MERGED",
      "author": "chris-wood",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #121.",
      "createdAt": "2022-04-22T15:16:57Z",
      "updatedAt": "2022-04-26T02:47:20Z",
      "baseRepository": "ietf-wg-privacypass/base-drafts",
      "baseRefName": "master",
      "baseRefOid": "e67114b94229ae902c89f55ac5b07406b21c3a0f",
      "headRepository": "ietf-wg-privacypass/base-drafts",
      "headRefName": "chris-wood-patch-1",
      "headRefOid": "62fc07fc2d194ea931bd909bcc90edac7f88e48e",
      "closedAt": "2022-04-26T02:47:20Z",
      "mergedAt": "2022-04-26T02:47:20Z",
      "mergedBy": "chris-wood",
      "mergeCommit": {
        "oid": "b428c5184870eee12fe0bec11dddd7fae620c889"
      },
      "comments": [
        {
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "body": "Is this the most exact way to put this? For byte arrays like a hash, I generally don't think of it as being network- or host- byte order. Do we have other docs that refer to stuff like this that we can crib from?",
          "createdAt": "2022-04-22T15:41:11Z",
          "updatedAt": "2022-04-22T15:41:11Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Nothing comes to mind right now, but I'm happy to look at alternatives.",
          "createdAt": "2022-04-22T15:46:37Z",
          "updatedAt": "2022-04-22T15:46:37Z"
        },
        {
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "body": "Works for me =) ",
          "createdAt": "2022-04-26T02:46:54Z",
          "updatedAt": "2022-04-26T02:46:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDODeTEy844pK3n",
          "commit": {
            "abbreviatedOid": "ec5b046"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-22T16:19:40Z",
          "updatedAt": "2022-04-22T16:19:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n- \"token_key_id\" is the least significant byte of the `key_id` in network byte order (in other words, the last 8 bits of `key_id`).\r\n```",
              "createdAt": "2022-04-22T16:19:40Z",
              "updatedAt": "2022-04-22T16:19:41Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy844pK6B",
          "commit": {
            "abbreviatedOid": "ec5b046"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-22T16:19:50Z",
          "updatedAt": "2022-04-22T16:19:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n- \"token_key_id\" is the least significant byte of the `key_id` in network byte order (in other words, the last 8 bits of `key_id`).\r\n```",
              "createdAt": "2022-04-22T16:19:50Z",
              "updatedAt": "2022-04-22T16:19:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDODeTEy844pLAh",
          "commit": {
            "abbreviatedOid": "ec5b046"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Here's an attempt at saying this in other words to be extra clear?",
          "createdAt": "2022-04-22T16:20:15Z",
          "updatedAt": "2022-04-22T16:20:15Z",
          "comments": []
        },
        {
          "id": "PRR_kwDODeTEy844yJqz",
          "commit": {
            "abbreviatedOid": "ec5b046"
          },
          "author": "chris-wood",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2022-04-26T02:46:36Z",
          "updatedAt": "2022-04-26T02:46:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\ud83d\udc4d Great!",
              "createdAt": "2022-04-26T02:46:36Z",
              "updatedAt": "2022-04-26T02:46:36Z"
            }
          ]
        }
      ]
    }
  ]
}